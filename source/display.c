/*
 * display.c
 *
 *  Created on: 9 de ago de 2022
 *      Author: andre
 */
#include "comum.h"

/* Structs externas */
extern QueueHandle_t fila_display;
extern QueueHandle_t fila_teclado;
extern TaskHandle_t xHandle;
extern flash_config_t s_flashDriver;

/* Variáveis externas */
extern unsigned int timerRTC;
extern volatile unsigned char flag_timer, flagNfcRead;
extern volatile unsigned char flagBuz;
extern unsigned char acesso, exame_feito;

/* Variáveis globais */
char data[6];
unsigned int voltageCalA_K = 0, voltageCalA_Ca = 0, voltageCalA_Cl = 0, voltageCalA_pH = 0, voltageCalA_Na = 0;
unsigned int voltageCalB_K = 0, voltageCalB_Ca = 0, voltageCalB_Cl = 0, voltageCalB_pH = 0, voltageCalB_Na = 0;
float Ck = 0, Cca = 0, Ccl = 0, CpH = 0, Cna = 0;
float Ck_standard = 0, Cca_standard = 0, Ccl_standard = 0, CpH_standard = 0, Cna_standard = 0;
float temperatura = 0;

void display_run( void ){

	unsigned char estado_display = 0, flagCalibOk = 0, menuConfig = 0, menuConfigAnterior = 0;
	unsigned char menu = 0, menu_anterior = 0, respCalibA = OK, respCalibB = OK, readQueueKeyboard;
	unsigned char readRxI2c = 0, timerErro = 0, contErro = 5;
	unsigned char verificaMaior;
	rst_off;
	for(int i = 0; i < 1000; i++ );
	rst_on;

	uart_config_t config;
	UART_GetDefaultConfig(&config);
	config.baudRate_Bps = 19200;
	config.enableTx     = true;
	config.enableRx     = true;
	UART_Init(UART3, &config, CLOCK_GetFreq(UART3_CLK_SRC));

	status(1);
	send_data(0x00);
	status(1);
	send_data(0x00);
	status(1);
	send_command(Set_text_home_addr);
	status(1);

	send_data(0x1E);
	status(1);
	send_data(0x00);
	status(1);
	send_command(Set_text_area);
	status(1);

	send_data(0xC0);
	status(1);
	send_data(0x03);
	status(1);
	send_command(Set_graphic_home_addr);
	status(1);

	send_data(0x1E);
	status(1);
	send_data(0x00);
	status(1);
	send_command(Set_graphic_area);
	status(1);

	send_data(0x02);
	status(1);
	send_data(0x00);
	status(1);
	send_command(Set_offset_register);
	status(1);

	send_command(Display_mode_graphic);
	status(1);

	send_data(0x00);
	status(1);
	send_data(0x00);
	status(1);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i < 4800; i++ ){
		send_data(0x00);
	}

	send_command(Auto_reset);
	status(2);

	send_data(0x00);
	status(1);
	send_data(0x00);
	status(1);
	send_command(Set_address_pointer);
	status(1);

	send_command(Display_mode_text);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i < 480; i++ ){
		send_data(0x00);
	}

	send_command(Auto_reset);
	status(2);

	// Escrita de valor 0xFF no dado para ser utilizado
	send_data(0x00);
	status(1);
	send_data(0x14);
	status(1);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i < 8; i++ ){
		send_data(0xFF);
	}
	// Escrita para 0x81 a letra A com til
	send_data(0x05);
	send_data(0x0A);
	send_data(0x04);
	send_data(0x0A);
	send_data(0x11);
	send_data(0x1F);
	send_data(0x11);
	send_data(0x00);

	// Escrita para 0x82 uma linha na 4° linha
	send_data(0x00);
	send_data(0x00);
	send_data(0x00);
	send_data(0x7E);
	send_data(0x00);
	send_data(0x00);
	send_data(0x00);
	send_data(0x00);

	send_command(Auto_reset);
	status(2);

	send_command(Mode_set_exor);
	status(2);

	//initEquip();

	desenho_menu1();
	WriteMenuName(menu, PRINCIPAL);

	send_command(Display_mode_text | Display_mode_graphic);
	status(1);

	I2C_READ_PCF8653( &readRxI2c, Control_Status_1 );
	if( readRxI2c != 0x00 ){
		configRTC();
	}

	unsigned char dia, mes, ano, hora, minuto, posicaoDesenho = 65;
	I2C_READ_PCF8653( &dia, Days );	// Faz a leitura do dia
	I2C_READ_PCF8653( &mes, Century_months );	// Faz a leitura do mês
	I2C_READ_PCF8653( &ano, Years );	// Faz a leitura do ano
	I2C_READ_PCF8653( &hora, Hours );	// Faz a leitura da hora
	I2C_READ_PCF8653( &minuto, Minutes );	// Faz a leitura do minuto
	escrita_texto( posicaoDesenho, ConverteNumParaLcd( 2, 0, bcdtodec( dia & 0x3F ) ), ContaCaracteres() + 1 );	// Escreve o dia salvo com 2 dígitos
	escrita_texto( posicaoDesenho + 2, "/" , sizeof("/") );	// Escreve "/"
	escrita_texto( posicaoDesenho + 3, ConverteNumParaLcd( 2, 0, bcdtodec( mes & 0x1F ) ), ContaCaracteres() + 1 );	// Escreve o mês salvo com 2 dígitos
	escrita_texto( posicaoDesenho + 5, "/20", sizeof("/20") );		// Escreve "/20"
	escrita_texto( posicaoDesenho + 8, ConverteNumParaLcd( 2, 0, bcdtodec( ano ) ), ContaCaracteres() + 1 );	// Escreve o ano salvo com 2 dígitos
	escrita_texto( posicaoDesenho + 12, ConverteNumParaLcd( 2, 0, bcdtodec( hora & 0x3F ) ), ContaCaracteres() + 1 );	// Escreve a hora salvo com 2 dígitos
	escrita_texto( posicaoDesenho + 14, ":" , sizeof(":") );	// Escreve ":"
	escrita_texto( posicaoDesenho + 15, ConverteNumParaLcd( 2, 0, bcdtodec( minuto & 0x7F ) ), ContaCaracteres() + 1 );	// Escreve o minuto salvo com 2 dígitos

	unsigned char timerRtcData = 0;
	unsigned char menuServico = 0, menuServicoAnterior = 0;
	adc16_channel_config_t adc16ChannelConfigStruct2;
	unsigned int temperaturaAD = 0;
	unsigned int media = 0;
	float calculoTemp = 0;

	while(1){

		readQueueKeyboard = verifyKeyBoard(); // Leitura do teclado
		/*
		adc16ChannelConfigStruct2.channelNumber = 26;
		ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct2);
		while (0U == (kADC16_ChannelConversionDoneFlag &
					  ADC16_GetChannelStatusFlags(ADC0, 0)))
		{
		}
		temperaturaAD = ADC16_GetChannelConversionValue(ADC0, 0);
		calculoTemp += temperaturaAD*3.3/4096;
		media++;
		 */
		if( timerRTC > 1000 && estado_display == 0 ){ // Caso não esteja verificando erros do sistema

			/*Escreve o texto do tempo a cada segundo
			 * Criar variável global para controle do tempo RTC (timerRTC)
			 * Se timerRTC for maior que 1000
			 * 		Zera timerRTC
			 * 		Escreve os segundos na tela
			 * 		Escreve :
			 * 		Escreve os minutos na tela
			 * 		Escreve :
			 * 		Escreve as horas na tela
			 */
			timerRTC = 0;
			timerRtcData++;

			/*
			calculoTemp /= media;
	        if(calculoTemp > 0.753)
	        	temperatura = 25 - (calculoTemp - 0.753)/0.00155;
	        else
	        	temperatura = 25 - (calculoTemp - 0.753)/0.00169;

	        calculoTemp = 0;
	        media = 0;
			 */
			if( timerRtcData > 60 && flagNfcRead == 0 )	// Contador de tempo para leitura de data e hora. A leitura será feita a cada minuto
			{
				timerRtcData = 0; // Zera contador de tempo
				I2C_READ_PCF8653( &dia, Days );	// Faz a leitura do dia
				I2C_READ_PCF8653( &mes, Century_months );	// Faz a leitura do mês
				I2C_READ_PCF8653( &ano, Years );	// Faz a leitura do ano
				I2C_READ_PCF8653( &hora, Hours );	// Faz a leitura da hora
				I2C_READ_PCF8653( &minuto, Minutes );	// Faz a leitura do minuto
				escrita_texto( posicaoDesenho, ConverteNumParaLcd( 2, 0, bcdtodec( dia & 0x3F ) ), ContaCaracteres() + 1 );	// Escreve o dia salvo com 2 dígitos
				escrita_texto( posicaoDesenho + 2, "/" , sizeof("/") );	// Escreve "/"
				escrita_texto( posicaoDesenho + 3, ConverteNumParaLcd( 2, 0, bcdtodec( mes & 0x1F ) ), ContaCaracteres() + 1 );	// Escreve o mês salvo com 2 dígitos
				escrita_texto( posicaoDesenho + 5, "/20", sizeof("/20") );		// Escreve "/20"
				escrita_texto( posicaoDesenho + 8, ConverteNumParaLcd( 2, 0, bcdtodec( ano ) ), ContaCaracteres() + 1 );	// Escreve o ano salvo com 2 dígitos
				escrita_texto( posicaoDesenho + 12, ConverteNumParaLcd( 2, 0, bcdtodec( hora & 0x3F ) ), ContaCaracteres() + 1 );	// Escreve a hora salvo com 2 dígitos
				escrita_texto( posicaoDesenho + 14, ":" , sizeof(":") );	// Escreve ":"
				escrita_texto( posicaoDesenho + 15, ConverteNumParaLcd( 2, 0, bcdtodec( minuto & 0x7F ) ), ContaCaracteres() + 1 );	// Escreve o minuto salvo com 2 dígitos
			}
			/* Verificação de erro */
			if( timerErro >= 3 && ( respCalibA != OK || respCalibB != OK || acesso != 1 ))	// Se temporizador de erro chegar a 5 segundos
			{
				timerErro = 0;
				if( !sensorRead )	// Se o sensor não está ativado, então mostra os outros erros
				{
					switch( contErro ){	// Escolha contErro
					case 0:	// Caso 0 - Falta de calibrador A

						if( respCalibA == ERRO_FALTA_CALIBA )	// Se flagCaliA for igual a ERRO_FALTA_CALIBA
						{
							clearLine(14);
							clearLine(15);
							escrita_texto(420, "Falta CAL A. Verifique a tubula", sizeof("Falta CAL A. Verifique a tubula"));	// Escreve "Falta calibrador A"
							EscreveCedilhaAOTil();
							escrita_texto(455, "e o pacote de reagentes", sizeof("e o pacote de reagentes"));

						}

						break;
					case 1:	// Caso 1 - Falta de calibrador B

						if( respCalibB == ERRO_FALTA_CALIBB )	// Se flagCaliB for igual a ERRO_FALTA_CALIBB
						{
							clearLine(14);
							clearLine(15);
							escrita_texto(420, "Falta CAL B. Verifique a tubula", sizeof("Falta CAL B. Verifique a tubula"));	// Escreve "Falta calibrador A"
							EscreveCedilhaAOTil();
							escrita_texto(455, "e o pacote de reagentes", sizeof("e o pacote de reagentes"));// Escreve "Falta calibrador B"
						}

						break;
					case 2:	// Caso 2 - mV fora da faixa

						if( ( verifyError(TYPEA, NOABNORMAL) & 0xFF ) > ( verifyError(TYPEB, NOABNORMAL) & 0xFF ) )
						{
							verificaMaior = TYPEA;
						}
						else
						{
							verificaMaior = TYPEB;
						}

						if( ( verifyError(verificaMaior, NOABNORMAL) & 0xFF ) != OK
								&& ( respCalibA == ERRO || respCalibB == ERRO ) )	// Se verifyError e 0xFF for difente de 0
						{
							clearLine(14);
							stateMachineError(420, verifyError(verificaMaior, NOABNORMAL) & 0xFF, 1);	// Chama máquina de estado de erro
						}

						break;
					case 3:	// Caso 3 - Anormal

						if( ( verifyError(TYPEB, ABNORMAL) >> 8 ) != OK
								&& ( respCalibA == ERRO || respCalibB == ERRO ) )	// Se verifyError move 8 bits para direita for difente de 0
						{
							clearLine(14);
							stateMachineError(420, verifyError(TYPEB, ABNORMAL) >> 8, 2);	// Chama máquina de estado de erro com o verifyError movido 8 bits para a direita
						}


						break;
					case 4:	// Caso 4 - Variando

						if( ( verifyError(TYPEA, NOABNORMAL) >> 16 ) > ( verifyError(TYPEB, NOABNORMAL) >> 16 ) )
						{
							verificaMaior = TYPEA;
						}
						else
						{
							verificaMaior = TYPEB;
						}

						if( ( verifyError(TYPEA, ABNORMAL) >> 16 ) != OK
								&& ( respCalibA == ERRO || respCalibB == ERRO ) )// Se verifyError move168 bits para direita for difente de 0
						{
							clearLine(14);
							stateMachineError(420, verifyError(TYPEB, NOABNORMAL) >> 16, 3);	// Chama máquina de estado de erro com o verifyError movido 16 bits para a direita
						}

						break;
					case 5:	// Caso 5 - Erro no NFC
						// Bloqueia o sensor
						clearLine(14);
						if( acesso == 2 )	// Se acesso igual a 2
						{
							escrita_texto(420, "Tag sem autoriza", sizeof("Tag sem autoriza" ));	// Escreve "Tag sem autorização"
							EscreveCedilhaAOTil();
						}
						else if( acesso == 3 )	// Senão se acesso igual a 3
						{
							escrita_texto(420, "Tag vencida", sizeof("Tag vencida"));	// Escreve "Tag vencida"
						}
						else if( acesso == 4 )	// Senão se acesso igual a 4
						{
							clearLine(15);
							escrita_texto(420, "CI sem comunicar. Trocar antena", sizeof("CI sem comunicar. Trocar antena"));	// Escreve "CI sem comunicar. Trocar antena"
						}
						else if( acesso == 0 )	// Senão
						{
							escrita_texto(420, "Sem tag", sizeof("Sem tag"));	// Escreve "Sem tag"
						}
						break;
					}
					contErro++;	// Contador de erro
					if( contErro == 6 )	// Se erro igual a 5
					{
						contErro = 0;	// Erro recebe 0
					}
				}

			}
			else
			{	// Senão
				timerErro++;	// Contador de tempo
				if( respCalibA == OK && respCalibB == OK && acesso == 1 && !sensorRead )	// Se está sem erro
				{
					// Apaga as linhas dos erros
					clearLine(14);
					clearLine(15);
				}
			}
		}

		switch(estado_display){
		case 0:

			if( readQueueKeyboard == left ){
				if( menu == 0 )
					menu = 8;
				else
					menu--;
			}
			else if( readQueueKeyboard == right ){
				if( menu == 8 )
					menu = 0;
				else
					menu++;
			}else if( readQueueKeyboard == um || ( readQueueKeyboard == yes && menu == 0 ) ){
				estado_display = 1;
				menu = 0;
				menu_anterior = 0;
				clear_display_text();
			}else if( readQueueKeyboard == dois || ( readQueueKeyboard == yes && menu == 1 ) ){
				estado_display = 2;
				menu = 1;
				menu_anterior = 1;
				clear_display_text();
			}
			// Se tecla igual a 3 ou menu igual a 2 e tecla igual a yes
			else if( readQueueKeyboard == tres || ( readQueueKeyboard == yes && menu == 2 ) ){
				estado_display = 3;	// Estado vai para a posição 3
				menu = 2;	// Salva a posição do menu
				menu_anterior = 2;	// Salva a posição do menu anterior
				clear_display_text();	// Limpa a tela
				telaManutencao();	// Escreve tela de Manutenção

			}
			else if( readQueueKeyboard == quatro || ( readQueueKeyboard == yes && menu == 3 ) ){
				estado_display = 4;
				menu = 3;
				menu_anterior = 3;
				clear_display_text();
			}
			// Se tecla igual a 8 ou menu igual a 7 e tecla igual a yes
			else if( readQueueKeyboard == oito || ( readQueueKeyboard == yes && menu == 7 ) ){
				estado_display = 8;	// Estado vai para a posição 3
				menu = 7;	// Salva a posição do menu
				menu_anterior = 7;	// Salva a posição do menu anterior
				menuConfig = 0;	// menuConfig recebe 0
				clear_display_text();	// Limpa a tela
				send_command(Display_mode_text | Display_mode_graphic);
				desenho_configuracao1(); // Escreve tela de Manutenção
				WriteMenuName(menuConfig, CONFIGURACAO);	// Escreve o título do comando
			}
			else if( readQueueKeyboard == nove || ( readQueueKeyboard == yes && menu == 8 ) ){
				estado_display = 9;	// Estado vai para a posição 9
				menu = 8;	// Salva a posição do menu
				menu_anterior = 7;	// Salva a posição do menu anterior
				menuConfig = 0;	// menuConfig recebe 0
				clear_display_text();	// Limpa a tela
				send_command(Display_mode_text | Display_mode_graphic);
				desenho_servicos1(); // Escreve tela de Manutenção
				WriteMenuName(menuConfig, SERVICO);	// Escreve o título do comando
			}

			readQueueKeyboard = 0;
			if( menu_anterior != menu ){
				WriteMenuName(menu, PRINCIPAL);
			}
			menu_anterior = menu;
			break;

		case 1:

			respCalibA = calibA(0);
			clear_display_text();
			desenho_menu1();
			WriteMenuName(menu, PRINCIPAL);
			send_command(Display_mode_text | Display_mode_graphic);
			status(1);
			estado_display = 0;

			break;

		case 2:

			respCalibA = calibA(0);	// Chama o calibrador A
			clear_display_text();	// Apaga a tela
			respCalibB = calibB();	// Chama o calibrador B
			if( respCalibA == OK && respCalibB == OK )	// Se as respostas forem OK
			{
				calibValues();	// Faz o cálculo da calibração dos valores padrão
				flagCalibOk = 1;	// Seta o flag de calibração OK
			}
			else if( respCalibA != OK || respCalibB != 0 )	// Se há erro
			{
				flagCalibOk = 0;	// Desliga o flag de calibração OK
			}
			clear_display_text();	// Apaga a tela
			desenho_menu1();	// Desenha a tela do menu 1
			WriteMenuName(menu, PRINCIPAL);	// Escreve o menu principal
			send_command(Display_mode_text | Display_mode_graphic);	// Chama o desenho da tela
			status(1);
			estado_display = 0;	// Volta o display para o estado inicial

			break;

		case 3:

			readQueueKeyboard = verifyKeyBoard();	// Lê o teclado

			if( readQueueKeyboard == um ){	// Se teclado igual a 1
				condicionamento();	// Chama função de condicionamento
				//estado_display = 2;
			}

			else if(  readQueueKeyboard == dois ){	// Senão se teclado igual a 2
				desproteinizacao();	// Chama função de desproteinização
				//estado_display = 2;	// Estado display recebe 2
			}
			else if(  readQueueKeyboard == tres ){	//Senão se teclado igual a 3
				calibA(1);	// Chama função lavando (calibA(1))
				clearLine(13);

			}
			else if(  readQueueKeyboard == quatro )	{// Senão se teclado igual a 4
				limpezaTubulacao();	// Chama função limpeza
				estado_display = 2;	// Estado display recebe 2
				clear_display_text();	// Limpa a tela
			}
			else if(  readQueueKeyboard == no ){	// Senão se teclado igual a NO

				clear_display_text();	// Limpa a tela
				desenho_menu1();	// Desenha Menu 1
				WriteMenuName(menu, PRINCIPAL);	// Desenha o nome do menu anterior
				send_command(Display_mode_text | Display_mode_graphic);
				status(1);
				estado_display = 0;// Estado display recebe 0

			}

			break;

		case 4:

			if( flagCalibOk ){

				TesteAmostras(0);
				clear_display_text();
				desenho_menu1();
				WriteMenuName(menu, PRINCIPAL);
				send_command(Display_mode_text | Display_mode_graphic);
				status(1);
				estado_display = 0;

			}
			else{

				clear_display_text();
				escrita_texto(210, "Calibre antes passar amostra", sizeof("Calibre antes passar amostra"));
				escrita_texto(270, "K,Na,Cl,Ca,pH sem calibrar", sizeof("K,Na,Cl,Ca,pH sem calibrar"));
				vTaskDelay(2000);
				clear_display_text();
				desenho_menu1();
				WriteMenuName(menu, PRINCIPAL);
				send_command(Display_mode_text | Display_mode_graphic);
				status(1);
				estado_display = 0;

			}
			break;

		case 8:

			if( readQueueKeyboard == left ){	// Se tecla igual a left
				if( menuConfig == 0 )	// Se menuConfig igual a 0
					menuConfig = 9;	// menuConfig recebe 9
				else	// Senão
					menuConfig--;	// menuConfig decrementa 1
			}
			else if( readQueueKeyboard == right ){	// Senão se tecla igual a right
				if( menuConfig == 9 )	// Se menuConfig igual a 9
					menuConfig = 0;	// menuConfig recebe 0
				else	// Senão
					menuConfig++;	// menuConfig incrementa 1
			}

			// Senão se tecla igual a 1 ou menuConfig igual a 0 e tecla igual a yes
			else if(readQueueKeyboard == 1 || ( menuConfig == 0 && readQueueKeyboard == yes ) ){
				menuConfig = 0;	// menuConfig recebe 2
				AtualizaHoraRTC();	// Chama a função AjustaHora();
				clear_display_text();	// Limpa a tela
				desenho_configuracao1();	// Desenha o menu 1
				WriteMenuName(menuConfig, CONFIGURACAO);	// Escreve o título do comando selecionado
				send_command(Display_mode_text | Display_mode_graphic);	// Modo de texto e gráfico junto
				status(1);
			}

			// Senão se tecla igual a 6 ou menuConfig igual a 5 e tecla igual a yes
			else if( readQueueKeyboard == 6 || ( menuConfig == 5 && readQueueKeyboard == yes ) ){
				menuConfig = 5;	// menuConfig recebe 6
				clear_display_text();
				AjustaCorrelacao();	// Chama a função AjustaCorrelação();
				clear_display_text();	// Limpa a tela
				desenho_configuracao2();	// Desenha o menu 1
				WriteMenuName(menuConfig, CONFIGURACAO);	// Escreve o título do comando selecionado
				send_command(Display_mode_text | Display_mode_graphic);	// Modo de texto e gráfico junto
				status(1);
			}

			// Senão se tecla igual a NO, retorna ao menu principal
			else if( readQueueKeyboard == no ){
				clear_display_text();	// Limpa a tela
				desenho_menu2();	// Desenha o menu 1
				WriteMenuName(menu, PRINCIPAL);	// Escreve o título do comando selecionado
				send_command(Display_mode_text | Display_mode_graphic);	// Modo de texto e gráfico junto
				status(1);
				estado_display = 0;	// Estado inicial
			}

			if( menuConfigAnterior != menuConfig )	// Se menuConfigAnterior for diferente de menuConfig
				WriteMenuName(menuConfig, CONFIGURACAO );	// Chama função WriteMenuName

			menuConfigAnterior = menuConfig;	// menuConfigAnterior recebe menuConfig
			break;

		case 9:
			if( readQueueKeyboard == left ){	// Se tecla igual a left
				if( menuServico == 0 )	// Se menuServico igual a 0
					menuServico = 6;	// menuServico recebe 6
				else	// Senão
					menuServico--;	// menuServico decrementa 1
			}
			else if( readQueueKeyboard == right ){	// Senão se tecla igual a right
				if( menuServico == 6 )	// Se menuServico igual a 6
					menuServico = 0;	// menuServico recebe 0
				else	// Senão
					menuServico++;	// menuServico incrementa 1
			}
			// Senão se tecla igual a 1 ou menuConfig igual a 0 e tecla igual a yes
			else if(readQueueKeyboard == dois || ( menuServico == 1 && readQueueKeyboard == yes ) ){
				menuServico = 0;	// menuServico recebe 2
				AtualizaHoraRTC();	// Chama a função AjustaHora();
				clear_display_text();	// Limpa a tela
				desenho_configuracao1();	// Desenha o menu 1
				WriteMenuName(menuServico, SERVICO);	// Escreve o título do comando selecionado
				send_command(Display_mode_text | Display_mode_graphic);	// Modo de texto e gráfico junto
				status(1);
			}
			break;
		}
	}

}

unsigned char status( unsigned char tipo ){

	unsigned char reg = 0;

	db0_on;
	db1_on;
	db2_on;
	db3_on;
	db4_on;
	db5_on;
	db6_on;
	db7_on;

	rst_on;
	wr_on;
	rd_off;
	cd_on;
	ce_off;

	if( tipo == 1 ){
		reg = 0;
		while(!((reg & 0x03) == 0x03)){

			reg = ( db7_read << 7 )
						| ( db6_read << 6 )
						| ( db5_read << 5 )
						| ( db4_read << 4 )
						| ( db3_read << 3 )
						| ( db2_read << 2 )
						| ( db1_read << 1 )
						| db0_read;

			reg = reg;

		}
	}
	else{

		reg = 0;
		while(!((reg & 0x80) == 0x80)){

			reg = ( db7_read << 7 )
						| ( db6_read << 6 )
						| ( db5_read << 5 )
						| ( db4_read << 4 )
						| ( db3_read << 3 )
						| ( db2_read << 2 )
						| ( db1_read << 1 )
						| db0_read;

			reg = reg;

		}


	}

	ce_on;
	wr_on;
	rd_on;
	cd_on;

	return reg;

}

unsigned char read_data( void ){

	unsigned char reg;

	db0_on;
	db1_on;
	db2_on;
	db3_on;
	db4_on;
	db5_on;
	db6_on;
	db7_on;

	rst_on;
	wr_on;
	rd_off;
	cd_off;
	ce_off;

	reg = ( db7_read << 7 )
				| ( db6_read << 6 )
				| ( db5_read << 5 )
				| ( db4_read << 4 )
				| ( db3_read << 3 )
				| ( db2_read << 2 )
				| ( db1_read << 1 )
				| db0_read;

	reg = reg;

	ce_on;
	wr_on;
	rd_on;
	cd_on;

	return reg;

}

void send_data( unsigned char data ){

	if( data & 0x01 )
		db0_on;
	else
		db0_off;

	if( data & 0x02 )
		db1_on;
	else
		db1_off;

	if( data & 0x04 )
		db2_on;
	else
		db2_off;

	if( data & 0x08 )
		db3_on;
	else
		db3_off;

	if( data & 0x10 )
		db4_on;
	else
		db4_off;

	if( data & 0x20 )
		db5_on;
	else
		db5_off;

	if( data & 0x40 )
		db6_on;
	else
		db6_off;

	if( data & 0x80 )
		db7_on;
	else
		db7_off;

	cd_off;
	wr_off;
	rd_on;
	ce_off;
	ce_on;
	cd_on;
	wr_on;
	rd_on;

}

void send_command( unsigned char command ){

	if( command & 0x01 )
		db0_on;
	else
		db0_off;

	if( command & 0x02 )
		db1_on;
	else
		db1_off;

	if( command & 0x04 )
		db2_on;
	else
		db2_off;

	if( command & 0x08 )
		db3_on;
	else
		db3_off;

	if( command & 0x10 )
		db4_on;
	else
		db4_off;

	if( command & 0x20 )
		db5_on;
	else
		db5_off;

	if( command & 0x40 )
		db6_on;
	else
		db6_off;

	if( command & 0x80 )
		db7_on;
	else
		db7_off;

	cd_on;
	wr_off;
	rd_on;
	ce_off;

	wr_on;
	rd_on;
	cd_on;
	ce_on;

}

void linha_horizontal8( unsigned char pos_y, unsigned char quant_dados8 ){

	unsigned int addr = 0x781 + pos_y * 30;

	if( pos_y > 55 || quant_dados8 > 28 )
		return;

	for( int j = 0; j < quant_dados8; j++ ){
		send_data((addr + j) & 0xFF);
		status(1);
		send_data((addr + j) >> 8);
		status(1);
		send_command(Set_address_pointer);
		status(1);

		send_command(Set_data_auto_write);
		status(2);

		send_data(0xFF);
		status(1);

		send_command(Auto_reset);
		status(2);
	}

}

void linha_horizontal( unsigned char pos_x, unsigned char pos_y, unsigned char quant_dados ){

	if( pos_y > 55 || quant_dados > 239 )
		return;
	for( int i = pos_x; i < pos_x + quant_dados; i++ )
		pixel( i, pos_y, 1 );

}

void linha_vertical( unsigned char pos_x, unsigned char pos_y, unsigned char quant_dados ){

	if( pos_x > 239 || quant_dados > 55 )
		return;
	for( int i = pos_y; i < pos_y + quant_dados; i++ )
		pixel(pos_x, i, 1);

}

void pixel( unsigned char pos_x, unsigned char pos_y, unsigned char on_off ){

	unsigned char dado = 0, data = 0;
	unsigned int addr = 0x780, coluna, linha;
	if( pos_x > 239 || pos_y > 56 )
		return;
	coluna = pos_x / 8;
	linha = 0x1E * pos_y;
	addr += linha + coluna;

	send_data(addr & 0xFF);
	status(1);
	send_data(addr >> 8);
	status(1);
	send_command(Set_address_pointer);
	status(1);

	send_command(0xC5);
	status(1);
	data = read_data();
	status(1);

	if( data )
		dado = data;

	if( on_off )
		dado |=  (0x80  >> ( pos_x % 8 ) );
	else
		dado &= ~(0x80  >> ( pos_x % 8 ) );

	send_data(dado);
	status(1);
	send_command(0xC4);
	status(1);

}

void desenha_fundo_menu( unsigned char posicao, unsigned char on_off ){


	// Escreve a tela no texto para fazer o EXOR
	for( int j = 0; j < 7; j++ ){
		send_data((0x79 + posicao*7 + j*30)& 0xFF);
		send_data((0x79 + posicao*7 + j*30) >> 8);
		send_command(Set_address_pointer);
		status(1);

		send_command(Set_data_auto_write);
		status(2);

		for( int i = 0; i < 7; i++ ){
			if( on_off )
				send_data(0x80);
			else
				send_data(0x00);
		}
		send_command(Auto_reset);
		status(2);
	}

}

void desenho_menu1( void ){

	unsigned int addr = 0x780;
	unsigned char desenho[] = {
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x7F ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x7 ,0xFF ,0xF8 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x8 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x80 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x8 ,0x0 ,0x4 ,0x0 ,0x1 ,0x80 ,0xE ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x1C ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1 ,0x0 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x10 ,0x0 ,0x2 ,0x0 ,0x1 ,0x80 ,0x1E ,0x0 ,0x3 ,0xE0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x3E ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x2 ,0x0 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x20 ,0x0 ,0x1 ,0x0 ,0x1 ,0x80 ,0x3E ,0x0 ,0x7 ,0xF0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x77 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x4 ,0x0 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x40 ,0x0 ,0x0 ,0x80 ,0x1 ,0x80 ,0x3C ,0x6 ,0xF ,0xF8 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0xE3 ,0x80 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x8 ,0x0 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x0 ,0x0 ,0x80 ,0x1 ,0x80 ,0x38 ,0x7 ,0x3F ,0xFC ,0x0 ,0x1 ,0x80 ,0x0 ,0x1 ,0xE3 ,0xC0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x10 ,0x0 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x0 ,0x0 ,0x80 ,0x1 ,0x80 ,0x38 ,0xF ,0x3F ,0xFC ,0x0 ,0x1 ,0x80 ,0x0 ,0x3 ,0xC1 ,0xE0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x20 ,0x0 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x83 ,0xFF ,0x80 ,0x80 ,0x1 ,0x80 ,0x1F ,0xE ,0x3F ,0xFC ,0x0 ,0x1 ,0x80 ,0x0 ,0x7 ,0x80 ,0xF0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x40 ,0x0 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x84 ,0x0 ,0x40 ,0x80 ,0x1 ,0x80 ,0x1F ,0xDE ,0x7F ,0xFF ,0xF0 ,0x1 ,0x80 ,0x0 ,0xF ,0x0 ,0x78 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x40 ,0x0 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x88 ,0x0 ,0x20 ,0x80 ,0x1 ,0x80 ,0xF ,0xFC ,0x7C ,0xFC ,0x0 ,0x1 ,0x80 ,0x0 ,0x1E ,0x0 ,0x3C ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x40 ,0x0 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x90 ,0x0 ,0x20 ,0x80 ,0x1 ,0x80 ,0x1F ,0xF8 ,0x3D ,0xFE ,0x0 ,0x1 ,0x80 ,0x0 ,0x3C ,0x0 ,0x1E ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x40 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0xA0 ,0x0 ,0x20 ,0x80 ,0x1 ,0x80 ,0x1F ,0x80 ,0x3F ,0xFF ,0x0 ,0x1 ,0x80 ,0x0 ,0x78 ,0x0 ,0xF ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x40 ,0xC0 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0xC0 ,0x0 ,0x20 ,0x80 ,0x1 ,0x80 ,0x3F ,0x0 ,0x3F ,0xFF ,0x0 ,0x1 ,0x80 ,0x1 ,0xF0 ,0x0 ,0x7 ,0xC0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x41 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x40 ,0x80 ,0x1 ,0x80 ,0x3F ,0x0 ,0x3F ,0xFC ,0x0 ,0x1 ,0x80 ,0x3 ,0xC0 ,0x0 ,0x1 ,0xE0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x42 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x80 ,0x80 ,0x1 ,0x80 ,0x3C ,0x0 ,0x3F ,0xFC ,0x0 ,0x1 ,0x80 ,0x7 ,0x80 ,0x0 ,0x0 ,0xF0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x44 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x1 ,0x0 ,0x80 ,0x1 ,0x80 ,0x3C ,0x0 ,0x3F ,0xFC ,0x0 ,0x1 ,0x80 ,0x7 ,0x0 ,0x0 ,0x0 ,0x70 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x48 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x2 ,0x0 ,0x80 ,0x1 ,0x80 ,0x7F ,0x0 ,0x3F ,0xFC ,0x0 ,0x1 ,0x80 ,0x1E ,0x0 ,0x0 ,0x0 ,0x3C ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x50 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x4 ,0x0 ,0x80 ,0x1 ,0x80 ,0x73 ,0x80 ,0x3F ,0xF3 ,0xE0 ,0x1 ,0x80 ,0x1E ,0x0 ,0x0 ,0x0 ,0x3C ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x60 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0xF ,0xF8 ,0x1 ,0x0 ,0x1 ,0x87 ,0xF1 ,0xC0 ,0x3F ,0xF3 ,0xF8 ,0x1 ,0x80 ,0x1C ,0x0 ,0x0 ,0x0 ,0x1C ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x10 ,0x0 ,0x2 ,0x0 ,0x1 ,0x8F ,0xE0 ,0xFF ,0x3F ,0xF3 ,0xFE ,0x1 ,0x80 ,0x38 ,0x0 ,0x0 ,0x0 ,0xE ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x20 ,0x0 ,0x4 ,0x0 ,0x1 ,0x9F ,0xE0 ,0xFF ,0x3F ,0xF3 ,0xFF ,0x1 ,0x80 ,0x38 ,0x0 ,0x0 ,0x0 ,0xE ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x40 ,0x0 ,0x8 ,0x0 ,0x1 ,0xBB ,0xF0 ,0x7F ,0x3F ,0xE3 ,0xFF ,0x81 ,0x80 ,0x70 ,0x0 ,0x0 ,0x0 ,0x7 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x0 ,0x10 ,0x0 ,0x1 ,0xB0 ,0xF8 ,0x7F ,0x0 ,0x3 ,0xC7 ,0xC1 ,0x80 ,0x70 ,0x0 ,0x0 ,0x0 ,0x7 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x0 ,0x20 ,0x0 ,0x1 ,0xB0 ,0x38 ,0x3F ,0x0 ,0x2 ,0x0 ,0x7D ,0x80 ,0x70 ,0x0 ,0x0 ,0x0 ,0x7 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x0 ,0x40 ,0x0 ,0x1 ,0xA0 ,0x38 ,0x3 ,0x0 ,0x3 ,0x7 ,0xF7 ,0x80 ,0x70 ,0x0 ,0x0 ,0x0 ,0x7 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x0 ,0x80 ,0x0 ,0x1 ,0x80 ,0x38 ,0x1 ,0x0 ,0x3 ,0xC ,0x7 ,0x80 ,0x70 ,0x0 ,0x0 ,0x0 ,0x7 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x7F ,0x0 ,0x0 ,0x1 ,0x80 ,0x38 ,0x3 ,0x0 ,0x3 ,0x8 ,0x3F ,0x80 ,0x70 ,0x0 ,0x0 ,0x0 ,0x7 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x80 ,0x0 ,0x0 ,0x1 ,0x80 ,0x30 ,0x3 ,0x0 ,0x3 ,0x83 ,0xFF ,0x80 ,0x70 ,0x0 ,0x0 ,0x0 ,0x7 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x81 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x70 ,0x6 ,0x0 ,0x3 ,0x87 ,0xFF ,0x80 ,0x70 ,0x0 ,0x0 ,0x0 ,0x7 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x82 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x60 ,0x4 ,0x0 ,0x1 ,0x87 ,0xFF ,0x80 ,0x38 ,0x0 ,0x0 ,0x0 ,0xE ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x82 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xC ,0x0 ,0x1 ,0xC7 ,0xE1 ,0x80 ,0x38 ,0x0 ,0x0 ,0x0 ,0xE ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x82 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x18 ,0x0 ,0x0 ,0xC7 ,0x1 ,0x80 ,0x18 ,0x0 ,0x0 ,0x0 ,0xC ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x82 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x10 ,0x0 ,0x0 ,0xC0 ,0x1 ,0x80 ,0x1C ,0x0 ,0x0 ,0x0 ,0x1C ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x82 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x30 ,0x7 ,0x80 ,0x40 ,0x1 ,0x80 ,0x1E ,0x0 ,0x0 ,0x0 ,0x3C ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x82 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x20 ,0x1E ,0xC0 ,0x60 ,0x1 ,0x80 ,0xE ,0x0 ,0x0 ,0x0 ,0x38 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x82 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x60 ,0x78 ,0x70 ,0x60 ,0x1 ,0x80 ,0x7 ,0x0 ,0x0 ,0x0 ,0x70 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x82 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x41 ,0xC0 ,0x18 ,0x20 ,0x1 ,0x80 ,0x3 ,0x80 ,0x0 ,0x0 ,0xE0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x82 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x1 ,0xC7 ,0x0 ,0xC ,0x20 ,0x1 ,0x80 ,0x1 ,0xE0 ,0x0 ,0x3 ,0xC0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x83 ,0xFF ,0xFF ,0x80 ,0x1 ,0x80 ,0x0 ,0x60 ,0x0 ,0x1 ,0xF0 ,0x1 ,0x80 ,0x0 ,0xF8 ,0x0 ,0xF ,0x80 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x0 ,0x0 ,0x80 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x60 ,0x1 ,0x80 ,0x0 ,0x3E ,0x0 ,0xE ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x0 ,0x0 ,0x80 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x40 ,0x1 ,0x80 ,0x0 ,0x1F ,0xC0 ,0x7C ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x0 ,0x0 ,0x80 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x7 ,0xFF ,0xF8 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x0 ,0x0 ,0x80 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x7F ,0xC0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x0 ,0x0 ,0x80 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x8E ,0x0 ,0x80 ,0x0 ,0x0 ,0x80 ,0x1 ,0x9F ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x8C ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x91 ,0x0 ,0x80 ,0x0 ,0x0 ,0x80 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x0 ,0x7F ,0x80 ,0x0 ,0x1 ,0x81 ,0x0 ,0xFF ,0xFF ,0xFF ,0x80 ,0x1 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8A ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x92 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9F ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x88 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9F ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,

	};

	send_data(addr & 0xFF);
	send_data(addr >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i <1680; i++  ){
		send_data(desenho[i]);
	}
	send_command(Auto_reset);
	status(2);

	escrita_texto(0x8, "MENU PRINCIPAL", sizeof("MENU PRINCIPAL"));

}

void desenho_menu2( void ){

	unsigned int addr = 0x780;
	unsigned char desenho[] = {
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xE ,0x3 ,0xE0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xE0 ,0x0 ,0x7 ,0x80 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x8 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0xF0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x1C ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1E ,0x1 ,0x80 ,0x0 ,0x0 ,0x38 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x3E ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0xC0 ,0x0 ,0x3 ,0xC1 ,0x80 ,0x0 ,0x0 ,0x7C ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x3 ,0x80 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x7F ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xE0 ,0x1C ,0x0 ,0x0 ,0x61 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x1F ,0xF8 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0xFF ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0xFC ,0x3 ,0x80 ,0x0 ,0x21 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x7F ,0xFE ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1 ,0xFF ,0xC0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xFF ,0x0 ,0x70 ,0x6 ,0x21 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x5 ,0x80 ,0xE4 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3 ,0xFF ,0xE0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x7F ,0xFC ,0x0 ,0x0 ,0x61 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0xF ,0x83 ,0xC0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFF ,0xF0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0x80 ,0x1 ,0xC1 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x1F ,0x3 ,0xF0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xF ,0xFF ,0xF8 ,0x0 ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xE0 ,0x7 ,0x81 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x1A ,0x7 ,0xF0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1F ,0xFF ,0xFC ,0x0 ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xF8 ,0x1E ,0x1 ,0x80 ,0x0 ,0xF ,0xFF ,0xE0 ,0x0 ,0x1 ,0x80 ,0x38 ,0xF ,0xE0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3F ,0xFF ,0xFE ,0x0 ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xFF ,0xF0 ,0x1 ,0x80 ,0xC7 ,0xFF ,0xFF ,0xFF ,0xC6 ,0x1 ,0x80 ,0x30 ,0xC ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7F ,0xFF ,0xFF ,0x0 ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xFF ,0x80 ,0x1 ,0x80 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFC ,0x1 ,0x80 ,0x20 ,0xC ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0xFF ,0xFF ,0xFF ,0xC0 ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xFF ,0x0 ,0x81 ,0x80 ,0x1 ,0x0 ,0xFE ,0x1 ,0x0 ,0x1 ,0x80 ,0xC0 ,0xE ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3 ,0xFF ,0xFF ,0xFF ,0xE0 ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xFF ,0x0 ,0x81 ,0x80 ,0x2 ,0x80 ,0xFE ,0x2 ,0x80 ,0x1 ,0x81 ,0xC0 ,0xC ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xFF ,0xFF ,0xFF ,0xF0 ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xFF ,0x0 ,0xC1 ,0x80 ,0x2 ,0x80 ,0xFE ,0x2 ,0x80 ,0x1 ,0x81 ,0x80 ,0x1C ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xFF ,0xFF ,0xFF ,0xF0 ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xFF ,0x0 ,0x81 ,0x80 ,0x6 ,0xC0 ,0xFE ,0x6 ,0xC0 ,0x1 ,0x83 ,0x0 ,0x3E ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x1F ,0xFF ,0xFF ,0xFF ,0xFC ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xFF ,0x0 ,0x81 ,0x80 ,0x4 ,0x40 ,0xFE ,0x4 ,0x40 ,0x1 ,0x87 ,0x0 ,0x3F ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x1F ,0xFF ,0xFF ,0xFF ,0xFC ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xFF ,0x0 ,0x81 ,0x80 ,0x4 ,0x40 ,0xFE ,0x4 ,0x40 ,0x1 ,0x8E ,0x0 ,0x67 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x1F ,0xFF ,0xFF ,0xFF ,0xFC ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xFF ,0x0 ,0x81 ,0x80 ,0xC ,0x60 ,0xFE ,0xC ,0x60 ,0x1 ,0x87 ,0x80 ,0x73 ,0xC0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0xFF ,0xFF ,0xFF ,0xFE ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xFF ,0x0 ,0x81 ,0x80 ,0x8 ,0x20 ,0xFE ,0x8 ,0x20 ,0x1 ,0x8B ,0x80 ,0xEC ,0xF0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0xFF ,0xFF ,0xFF ,0xFE ,0x1 ,0x80 ,0x0 ,0x3F ,0xFF ,0xFF ,0x0 ,0x81 ,0x80 ,0x8 ,0x20 ,0xFE ,0x8 ,0x20 ,0x1 ,0x9F ,0x9 ,0xDF ,0xFC ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0x1 ,0x80 ,0x0 ,0x3F ,0xFF ,0xFF ,0x1 ,0x81 ,0x80 ,0x18 ,0x30 ,0xFE ,0x18 ,0x30 ,0x1 ,0x9E ,0x1F ,0xFF ,0x3E ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0x1 ,0x80 ,0x7 ,0xC7 ,0xFF ,0xFF ,0x1 ,0x1 ,0x80 ,0x10 ,0x10 ,0xFE ,0x10 ,0x10 ,0x1 ,0x96 ,0x1F ,0xFF ,0xFF ,0x80 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0x1 ,0x80 ,0x3C ,0x0 ,0x7F ,0xFF ,0x3 ,0x1 ,0x80 ,0x10 ,0x10 ,0xFE ,0x10 ,0x10 ,0x1 ,0xB0 ,0x3B ,0x1F ,0xBB ,0xE0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0x1 ,0x80 ,0xC0 ,0x0 ,0xF ,0xFF ,0x6 ,0x1 ,0x80 ,0x30 ,0x18 ,0xFE ,0x30 ,0x18 ,0x1 ,0xF8 ,0x30 ,0x7 ,0xDF ,0xFC ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0x1 ,0x81 ,0x80 ,0x0 ,0x3 ,0xFE ,0xE ,0x1 ,0x80 ,0x20 ,0x8 ,0xFE ,0x20 ,0x8 ,0x1 ,0xFE ,0x38 ,0x3 ,0xF7 ,0x3E ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0x1 ,0x83 ,0x0 ,0x0 ,0x0 ,0xFE ,0xC ,0x1 ,0x80 ,0x20 ,0x8 ,0xFE ,0x20 ,0x8 ,0x1 ,0xBF ,0xB0 ,0x0 ,0xFF ,0xF3 ,0xF0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0x1 ,0x86 ,0x0 ,0x0 ,0x2 ,0xF ,0xE0 ,0x1 ,0x80 ,0x60 ,0xC ,0xFE ,0x60 ,0xC ,0x1 ,0x9F ,0xF0 ,0x0 ,0x3A ,0xD9 ,0xF8 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0x1 ,0x87 ,0x0 ,0x0 ,0x1C ,0x40 ,0x80 ,0x1 ,0x80 ,0x40 ,0x4 ,0xFE ,0x40 ,0x4 ,0x1 ,0x9F ,0xE0 ,0x0 ,0xD ,0x64 ,0x7C ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0xFF ,0xFF ,0xFF ,0xFE ,0x1 ,0x87 ,0x80 ,0x0 ,0xF8 ,0xC1 ,0x80 ,0x1 ,0x80 ,0x40 ,0x4 ,0xFE ,0x40 ,0x4 ,0x1 ,0x87 ,0xC0 ,0x0 ,0xE ,0x9B ,0xBF ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0xFF ,0xFF ,0xFF ,0xFE ,0x1 ,0x87 ,0xFF ,0xFF ,0xE1 ,0x81 ,0x0 ,0x1 ,0x80 ,0x40 ,0x4 ,0xFE ,0x40 ,0x4 ,0x1 ,0x81 ,0xC0 ,0x0 ,0x6 ,0xCC ,0xCF ,0x81 ,0x0 ,
			0x0 ,0x80 ,0x1F ,0xFF ,0xFF ,0xFF ,0xFC ,0x1 ,0x87 ,0xFF ,0xFC ,0x3 ,0x1 ,0x0 ,0x1 ,0x80 ,0xFF ,0xFE ,0xFE ,0xFF ,0xFE ,0x1 ,0x80 ,0x0 ,0x0 ,0x3 ,0x64 ,0x77 ,0xE1 ,0x0 ,
			0x0 ,0x80 ,0x1F ,0xFF ,0xFF ,0xFF ,0xFC ,0x1 ,0x83 ,0xFF ,0x0 ,0xE ,0x83 ,0x0 ,0x1 ,0x80 ,0x7F ,0xFC ,0xFE ,0x7F ,0xFC ,0x1 ,0x80 ,0x0 ,0x0 ,0x1 ,0xBA ,0x9 ,0xF1 ,0x0 ,
			0x0 ,0x80 ,0x1F ,0xFF ,0xFF ,0xFF ,0xFC ,0x1 ,0x81 ,0xFF ,0x81 ,0xF9 ,0x83 ,0x0 ,0x1 ,0x80 ,0x3F ,0xF8 ,0xFE ,0x3F ,0xF8 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0xFD ,0xB3 ,0x39 ,0x0 ,
			0x0 ,0x80 ,0xF ,0xFF ,0xFF ,0xFF ,0xF8 ,0x1 ,0x80 ,0xFF ,0x80 ,0x0 ,0x41 ,0x0 ,0x1 ,0x80 ,0x1F ,0xF0 ,0xFE ,0x1F ,0xF0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x3F ,0xCD ,0x8F ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xFF ,0xFF ,0xFF ,0xF0 ,0x1 ,0x80 ,0xFF ,0x0 ,0x0 ,0xC3 ,0x0 ,0x1 ,0x80 ,0xF ,0xE0 ,0xFE ,0xF ,0xE0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x1F ,0xFE ,0x6F ,0x0 ,
			0x0 ,0x80 ,0x3 ,0xFF ,0xFF ,0xFF ,0xE0 ,0x1 ,0x80 ,0xFF ,0x80 ,0x0 ,0x83 ,0x0 ,0x1 ,0x80 ,0x7 ,0xC0 ,0xFE ,0x7 ,0xC0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0xD ,0xFD ,0xB7 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0xFF ,0xFF ,0xFF ,0xC0 ,0x1 ,0x80 ,0x7F ,0x0 ,0x1 ,0x9F ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x7 ,0x7F ,0x5F ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xFF ,0xFF ,0xFF ,0x80 ,0x1 ,0x80 ,0x7F ,0x0 ,0x1 ,0xBE ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x3 ,0xFF ,0xBF ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3F ,0xFF ,0xFE ,0x0 ,0x1 ,0x80 ,0x7F ,0x0 ,0x3 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x3 ,0xFF ,0xFD ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1F ,0xFF ,0xFC ,0x0 ,0x1 ,0x80 ,0x7F ,0x0 ,0x2 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7D ,0xF9 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFF ,0xF8 ,0x0 ,0x1 ,0x80 ,0x3F ,0xF0 ,0x4 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0xF ,0xF1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x7F ,0xC0 ,0x0 ,0x1 ,0x80 ,0x3F ,0xFE ,0x0 ,0x30 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7 ,0xF1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x1F ,0xFF ,0xC0 ,0xF0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0xF1 ,0x0 ,
			0x0 ,0x9F ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x86 ,0x33 ,0xFE ,0x3 ,0x90 ,0x0 ,0x1 ,0x9F ,0x0 ,0x1 ,0xFF ,0x0 ,0x0 ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x61 ,0x0 ,
			0x0 ,0x90 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x88 ,0x38 ,0x1C ,0xC ,0x30 ,0x0 ,0x1 ,0x81 ,0x0 ,0x3 ,0xFF ,0x80 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x9E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x90 ,0x3E ,0x0 ,0x0 ,0xF0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x7 ,0xFF ,0xC0 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9E ,0x3F ,0x0 ,0x3 ,0xC0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x7 ,0xE0 ,0xF8 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x1 ,0xE1 ,0xC0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8E ,0x0 ,0xFF ,0x0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,

	};
	send_data(addr & 0xFF);
	send_data(addr >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i <1680; i++  ){
		send_data(desenho[i]);
	}
	send_command(Auto_reset);
	status(2);

	escrita_texto(0x8, "MENU PRINCIPAL", sizeof("MENU PRINCIPAL"));

}

void desenho_menu3( void ){

	unsigned int addr = 0x780;
	unsigned char desenho[] = {
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x60 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1 ,0xFC ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3 ,0xFE ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFE ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFF ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xF ,0xFF ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1 ,0xFF ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x6 ,0x3F ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xF ,0xC1 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1F ,0xFC ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xF ,0xFE ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFE ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFD ,0x80 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3 ,0xFB ,0xE0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0xE7 ,0x38 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3 ,0x1F ,0xC ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3 ,0xF9 ,0x6 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0x1 ,0x3 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0x1 ,0x1 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x83 ,0x60 ,0xF ,0x1 ,0x1 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x83 ,0xE0 ,0x3B ,0x1 ,0x1 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x81 ,0xC1 ,0xF3 ,0xFF ,0x21 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x81 ,0x9F ,0xC3 ,0xFF ,0x31 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x83 ,0xD8 ,0x3 ,0xFF ,0x31 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x83 ,0xD8 ,0x3 ,0xFF ,0xB1 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x83 ,0x98 ,0x1F ,0xFF ,0xF1 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x81 ,0xDF ,0xFF ,0xFF ,0xF1 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x83 ,0x6F ,0xC7 ,0xFF ,0xF1 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x83 ,0x40 ,0x7 ,0xFF ,0xFF ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFF ,0xE0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFF ,0xFF ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFF ,0xFF ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFF ,0xFB ,0xE0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xF ,0xFF ,0xEB ,0x60 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1F ,0xFF ,0xEE ,0xC0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3F ,0xFF ,0xE7 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3F ,0xFF ,0xEF ,0xC0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7F ,0xF3 ,0xEF ,0xC0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xFF ,0xE3 ,0xEF ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xFF ,0xC1 ,0xFF ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0xFF ,0x81 ,0xFF ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3 ,0xFF ,0x0 ,0xFF ,0xC0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3 ,0xFE ,0x0 ,0x7F ,0xE0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xFE ,0x0 ,0x7F ,0xF0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xFC ,0x0 ,0x3F ,0xF8 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x8E ,0x3F ,0xFC ,0x0 ,0x1F ,0xF0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x91 ,0x1F ,0xF8 ,0x0 ,0x1F ,0xC0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x91 ,0x7 ,0xF8 ,0x0 ,0xF ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x8F ,0x1 ,0xF0 ,0x0 ,0xE ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x81 ,0x0 ,0x30 ,0x0 ,0x18 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x8C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,

	};
	send_data(addr & 0xFF);
	send_data(addr >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i <1680; i++  ){
		send_data(desenho[i]);
	}
	send_command(Auto_reset);
	status(2);

	escrita_texto(0x8, "MENU PRINCIPAL", sizeof("MENU PRINCIPAL"));

}

void desenho_configuracao1( void ){

	unsigned int addr = 0x780;
	unsigned char desenho[] = {
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1 ,0xFF ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3 ,0xFF ,0xC0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xF ,0x83 ,0xE0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x2 ,0x0 ,0xC8 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xF ,0x1 ,0xE0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x4 ,0x0 ,0xD0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0xE7 ,0xC3 ,0xE0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x8 ,0x0 ,0xE0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3 ,0xFF ,0xFF ,0xE0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x1 ,0xFF ,0x0 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x1 ,0x10 ,0x0 ,0xF0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xFB ,0xFF ,0xC0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x3 ,0xFF ,0x80 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0xA0 ,0x0 ,0xD8 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xF9 ,0xFF ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x7 ,0x83 ,0xC0 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x40 ,0x0 ,0xC8 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0x3D ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xE ,0x8 ,0xE0 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xBF ,0xFF ,0xF8 ,0x0 ,0x1 ,0x80 ,0x0 ,0xC ,0x8 ,0x60 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xFF ,0xFF ,0xFC ,0x0 ,0x1 ,0x80 ,0x0 ,0x18 ,0x18 ,0x30 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3 ,0xFF ,0xC1 ,0xFF ,0x0 ,0x1 ,0x80 ,0x0 ,0x18 ,0x18 ,0x30 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3 ,0xFE ,0x3C ,0x3F ,0x80 ,0x1 ,0x80 ,0x0 ,0x1F ,0xFF ,0xF0 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3 ,0xF8 ,0x7E ,0x7 ,0xC0 ,0x1 ,0x80 ,0x0 ,0x1F ,0xFF ,0xF0 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x2 ,0x0 ,0xC3 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xE0 ,0xFF ,0x7 ,0xE0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x4 ,0x0 ,0xE3 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0xF ,0xC0 ,0xEF ,0x83 ,0xF0 ,0x1 ,0x80 ,0x7 ,0xFF ,0xFF ,0xFF ,0xC0 ,0x1 ,0x9C ,0x3 ,0x80 ,0x0 ,0x1 ,0xC0 ,0x39 ,0x80 ,0x0 ,0x8 ,0x0 ,0xD3 ,0x7C ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0x0 ,0xFF ,0xBE ,0xF0 ,0x1 ,0x80 ,0x7 ,0xFF ,0xFF ,0xFF ,0xC0 ,0x1 ,0x9C ,0x3 ,0x80 ,0x0 ,0x1 ,0xC0 ,0x39 ,0x80 ,0x1 ,0x10 ,0x0 ,0xCB ,0x1C ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0x0 ,0xE3 ,0xBE ,0x78 ,0x1 ,0x80 ,0x7 ,0xFF ,0xFF ,0xFF ,0xC0 ,0x1 ,0x9C ,0x3 ,0x80 ,0x0 ,0x1 ,0xC0 ,0x39 ,0x80 ,0x0 ,0xA0 ,0x0 ,0xC7 ,0x64 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0x0 ,0xFF ,0x9E ,0x3C ,0x1 ,0x80 ,0x7 ,0xFF ,0xFF ,0xFF ,0xC0 ,0x1 ,0x9C ,0x1C ,0x0 ,0x0 ,0x0 ,0x38 ,0x39 ,0x80 ,0x0 ,0x40 ,0x0 ,0xC3 ,0x7C ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7E ,0x0 ,0x7F ,0x3E ,0x3C ,0x1 ,0x80 ,0x7 ,0xFF ,0xFF ,0xFF ,0xC0 ,0x1 ,0x9C ,0x1C ,0x0 ,0x0 ,0x0 ,0x38 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7E ,0x0 ,0x3E ,0x7E ,0x1E ,0x1 ,0x83 ,0x87 ,0xFF ,0xEF ,0xFF ,0xC1 ,0x1 ,0x9C ,0x1C ,0x0 ,0x0 ,0x0 ,0x38 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7C ,0x0 ,0x0 ,0xFE ,0xE ,0x1 ,0x83 ,0x87 ,0xFF ,0xC7 ,0xFF ,0xC3 ,0x81 ,0x9C ,0xE0 ,0x0 ,0x0 ,0x0 ,0x7 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0xFC ,0x0 ,0x1 ,0xF8 ,0xF ,0x1 ,0x83 ,0x87 ,0xFF ,0x83 ,0xFF ,0xC7 ,0xC1 ,0x9C ,0xE0 ,0x0 ,0x0 ,0x0 ,0x7 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0xF8 ,0x0 ,0x3 ,0xE0 ,0xF ,0x1 ,0x83 ,0x87 ,0xFF ,0x1 ,0xFF ,0xCF ,0xE1 ,0x9C ,0xE0 ,0x0 ,0x0 ,0x0 ,0x7 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0xF8 ,0x0 ,0x7 ,0xD8 ,0xF ,0x1 ,0x83 ,0x87 ,0xFF ,0x83 ,0xFF ,0xDF ,0xF1 ,0x9F ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xF9 ,0x80 ,0x0 ,0x2 ,0x0 ,0xFD ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x81 ,0xFE ,0x0 ,0x7 ,0x98 ,0x3F ,0x1 ,0x83 ,0x87 ,0xFF ,0xC7 ,0xFF ,0xC3 ,0x81 ,0x9F ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xF9 ,0x80 ,0x0 ,0x4 ,0x0 ,0xC5 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x81 ,0xFF ,0x0 ,0xF ,0xFE ,0x7F ,0x1 ,0x83 ,0x87 ,0xFF ,0xC7 ,0xFF ,0xC3 ,0x81 ,0x9F ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xF9 ,0x80 ,0x0 ,0x8 ,0x0 ,0xC1 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x81 ,0xFF ,0x0 ,0x1F ,0xFE ,0x7F ,0x1 ,0x83 ,0x87 ,0xFC ,0x0 ,0x7F ,0xC3 ,0x81 ,0x9F ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xF9 ,0x80 ,0x1 ,0x10 ,0x0 ,0xC1 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x81 ,0xFF ,0x0 ,0x3F ,0xF8 ,0x3F ,0x1 ,0x83 ,0x87 ,0xF8 ,0x0 ,0x3F ,0xC3 ,0x81 ,0x9C ,0xE0 ,0x0 ,0x0 ,0x0 ,0x7 ,0x39 ,0x80 ,0x0 ,0xA0 ,0x0 ,0xC5 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x81 ,0xF0 ,0x0 ,0x7F ,0x98 ,0xF ,0x1 ,0x83 ,0x87 ,0xF0 ,0x0 ,0x1F ,0xC3 ,0x81 ,0x9C ,0xE0 ,0x0 ,0x0 ,0x0 ,0x7 ,0x39 ,0x80 ,0x0 ,0x40 ,0x0 ,0xFD ,0xC0 ,0x1 ,0x0 ,
			0x0 ,0x81 ,0xF8 ,0x0 ,0x0 ,0x0 ,0xF ,0x1 ,0x9F ,0xF7 ,0xF3 ,0x1 ,0x9F ,0xC3 ,0x81 ,0x9C ,0xE0 ,0x0 ,0x0 ,0x0 ,0x7 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x81 ,0xF8 ,0x0 ,0x0 ,0x0 ,0xF ,0x1 ,0x8F ,0xE7 ,0xE7 ,0x1 ,0x9F ,0xC3 ,0x81 ,0x9C ,0x1C ,0x0 ,0x0 ,0x0 ,0x38 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0xFC ,0x0 ,0x0 ,0x0 ,0xF ,0x1 ,0x87 ,0xC7 ,0xE7 ,0x1 ,0x9F ,0xC3 ,0x81 ,0x9C ,0x1C ,0x0 ,0x0 ,0x0 ,0x38 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0xFC ,0x0 ,0x0 ,0x0 ,0xF ,0x1 ,0x83 ,0x87 ,0xE7 ,0x1 ,0x9F ,0xC3 ,0x81 ,0x9C ,0x1C ,0x0 ,0x0 ,0x0 ,0x38 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7C ,0x0 ,0x0 ,0x0 ,0x1E ,0x1 ,0x81 ,0x7 ,0xE7 ,0x1 ,0x9F ,0xC3 ,0x81 ,0x9C ,0x3 ,0x80 ,0x0 ,0x1 ,0xC0 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7E ,0x0 ,0x0 ,0x0 ,0x1E ,0x1 ,0x80 ,0x7 ,0xFF ,0x1 ,0xFF ,0xC0 ,0x1 ,0x9C ,0x3 ,0x80 ,0x0 ,0x1 ,0xC0 ,0x39 ,0x80 ,0x0 ,0x2 ,0x0 ,0xFC ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7E ,0x0 ,0x0 ,0x0 ,0x3C ,0x1 ,0x80 ,0x7 ,0xFF ,0x1 ,0xFF ,0xC0 ,0x1 ,0x9C ,0x3 ,0x80 ,0x0 ,0x1 ,0xC0 ,0x39 ,0x80 ,0x0 ,0x4 ,0x0 ,0xC4 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0x0 ,0x0 ,0x0 ,0x78 ,0x1 ,0x80 ,0x7 ,0xFF ,0x1 ,0xFF ,0xC0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x8 ,0x0 ,0xC1 ,0xF0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0x80 ,0x0 ,0x0 ,0xF0 ,0x1 ,0x80 ,0x7 ,0xFF ,0x1 ,0xFF ,0xC0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x1 ,0x10 ,0x0 ,0xC0 ,0x70 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x1F ,0xC0 ,0x0 ,0x1 ,0xF0 ,0x1 ,0x80 ,0x7 ,0xFF ,0x1 ,0xFF ,0xC0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0xA0 ,0x0 ,0xC5 ,0x90 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0xF ,0xE0 ,0x0 ,0x3 ,0xE0 ,0x1 ,0x80 ,0x7 ,0xFF ,0x1 ,0xFF ,0xC0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x40 ,0x0 ,0xFD ,0xF0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xF0 ,0x1C ,0x7 ,0xC0 ,0x1 ,0x80 ,0x7 ,0xFF ,0x10 ,0xFF ,0xC0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3 ,0xFC ,0x1C ,0xF ,0x80 ,0x1 ,0x80 ,0x7 ,0xFF ,0x10 ,0xFF ,0xC0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0xFF ,0x9C ,0x7F ,0x0 ,0x1 ,0x80 ,0x7 ,0xFF ,0x18 ,0xFF ,0xC0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7F ,0xFF ,0xF8 ,0x0 ,0x1 ,0x80 ,0x7 ,0xFF ,0x1C ,0xFF ,0xC0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1F ,0xFF ,0xF0 ,0x0 ,0x1 ,0x80 ,0x7 ,0xFF ,0x3C ,0xFF ,0xC0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1 ,0xFF ,0xC0 ,0x0 ,0x1 ,0x80 ,0x7 ,0xFF ,0x3C ,0xFF ,0xC0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x2 ,0x0 ,0x3 ,0x30 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x1 ,0xE1 ,0xE0 ,0x0 ,0x1 ,0x8E ,0x7 ,0xFF ,0x3C ,0xFF ,0xC0 ,0x1 ,0x8F ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x4 ,0x0 ,0x3 ,0x30 ,0x1 ,0x0 ,
			0x0 ,0x8C ,0x0 ,0x1 ,0xE1 ,0xF0 ,0x0 ,0x1 ,0x91 ,0x7 ,0xFF ,0x3C ,0xFF ,0xC0 ,0x1 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x8 ,0x0 ,0xFB ,0xF0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x61 ,0xE0 ,0xF8 ,0x0 ,0x1 ,0x81 ,0x7 ,0xFF ,0x3C ,0xFF ,0xC0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8A ,0x1 ,0x10 ,0x0 ,0xCB ,0xF0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0xF9 ,0xC0 ,0xF8 ,0x0 ,0x1 ,0x82 ,0x7 ,0xFF ,0x3C ,0xFF ,0xC0 ,0x1 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x92 ,0x0 ,0xA0 ,0x0 ,0xFB ,0x30 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0xFF ,0xC1 ,0xFC ,0x0 ,0x1 ,0x84 ,0x7 ,0xFF ,0xFF ,0xFF ,0xC0 ,0x1 ,0x80 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9F ,0x0 ,0x40 ,0x0 ,0xC3 ,0x30 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x7F ,0x83 ,0xFC ,0x0 ,0x1 ,0x88 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x88 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x8E ,0x0 ,0x1F ,0x87 ,0xFC ,0x0 ,0x1 ,0x9F ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x87 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,

	};
	send_data(addr & 0xFF);
	send_data(addr >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i <1680; i++  ){
		send_data(desenho[i]);
	}
	send_command(Auto_reset);
	status(2);

	escrita_texto(0x9, "CONFIGURA", sizeof("CONFIGURA"));
	EscreveCedilhaAOTil();

}

void desenho_configuracao2( void ){

	unsigned int addr = 0x780;
	unsigned char desenho[] = {
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x1 ,0xF0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xF ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xF ,0x1F ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xF ,0x3 ,0xE0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xC ,0xC0 ,0xF8 ,0x0 ,0x1 ,0x8F ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xF1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x3C ,0x38 ,0x3E ,0x0 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x3 ,0x80 ,0x1 ,0x80 ,0x0 ,0xFE ,0x6 ,0x7 ,0x80 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x7 ,0x80 ,0x1 ,0xBF ,0xFF ,0x80 ,0x80 ,0x70 ,0x78 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x3 ,0x80 ,0x1 ,0xF8 ,0x7C ,0x0 ,0x60 ,0xC ,0x18 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0xF ,0xC0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x3 ,0x80 ,0x1 ,0xE0 ,0x30 ,0x0 ,0x30 ,0xE0 ,0x38 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x1F ,0xE0 ,0x1 ,0x80 ,0x4 ,0x0 ,0x0 ,0x3 ,0xC7 ,0x1 ,0xE8 ,0x6 ,0x0 ,0xF ,0x1 ,0xC8 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x3F ,0xF0 ,0x1 ,0x80 ,0x44 ,0x0 ,0x0 ,0x77 ,0xFF ,0xC1 ,0xE2 ,0x1 ,0x80 ,0xC ,0x6 ,0x8 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x7F ,0xF0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x7 ,0xFF ,0xE0 ,0xF1 ,0xE0 ,0x80 ,0x40 ,0xC0 ,0x38 ,0x8 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x7F ,0xF0 ,0x1 ,0x83 ,0x0 ,0x0 ,0x1F ,0xFF ,0xB0 ,0x31 ,0xE0 ,0x40 ,0x31 ,0x0 ,0xE0 ,0x8 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x7F ,0xF0 ,0x1 ,0x80 ,0x7 ,0x80 ,0x1F ,0xFE ,0x38 ,0x11 ,0xE8 ,0xC ,0x0 ,0x1C ,0x0 ,0x8 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x1F ,0xFF ,0xF0 ,0x1 ,0x80 ,0xF ,0x80 ,0x3F ,0xFC ,0x3C ,0x11 ,0xF2 ,0x3 ,0x0 ,0xE0 ,0x0 ,0x8 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x1F ,0xFF ,0xF0 ,0x1 ,0x90 ,0xF ,0x80 ,0x3F ,0xF0 ,0xFE ,0x1 ,0xE4 ,0x80 ,0x83 ,0x0 ,0x0 ,0x28 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0xF ,0xFF ,0xE0 ,0x1 ,0x80 ,0xF ,0x80 ,0x3F ,0x83 ,0xFF ,0x81 ,0xF9 ,0x0 ,0x7C ,0x0 ,0x1 ,0xE8 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x7 ,0xFF ,0xC0 ,0x1 ,0x83 ,0xF ,0x8F ,0x3F ,0xF ,0xFF ,0xF1 ,0xF6 ,0xD0 ,0x10 ,0x0 ,0x2 ,0x28 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x3 ,0xFF ,0x80 ,0x1 ,0x87 ,0xBF ,0xCF ,0x3E ,0x1F ,0xF0 ,0x1 ,0xED ,0x8C ,0x10 ,0x0 ,0x1F ,0x28 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x19 ,0xFC ,0x0 ,0x1 ,0x87 ,0xFF ,0xFF ,0x3C ,0xF ,0xF0 ,0x1 ,0xE2 ,0x53 ,0x10 ,0x0 ,0x7D ,0xB8 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x38 ,0xFC ,0x0 ,0x1 ,0x83 ,0xFF ,0xFE ,0x3C ,0x1F ,0xF0 ,0x1 ,0xFC ,0x49 ,0x50 ,0x7 ,0xC0 ,0x38 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x60 ,0x7C ,0x0 ,0x1 ,0x81 ,0xFF ,0xFE ,0x38 ,0x3F ,0xF0 ,0x1 ,0xEF ,0x12 ,0x90 ,0x3F ,0x0 ,0x18 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0xE0 ,0x3C ,0x0 ,0x1 ,0x83 ,0xF8 ,0xFF ,0xF8 ,0x7F ,0xF8 ,0x1 ,0xE3 ,0xCD ,0x50 ,0xFE ,0x0 ,0x6 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1 ,0x81 ,0xDC ,0x0 ,0x1 ,0x87 ,0xF0 ,0x7F ,0x0 ,0xFF ,0xFC ,0x1 ,0xE0 ,0xE2 ,0x13 ,0x7C ,0x0 ,0x0 ,0xC1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3 ,0x81 ,0x8C ,0x0 ,0x1 ,0x87 ,0xE0 ,0x7F ,0x1 ,0xFF ,0xFE ,0x1 ,0xE0 ,0x38 ,0x92 ,0x70 ,0x0 ,0x0 ,0x19 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0x87 ,0x0 ,0x0 ,0x1 ,0xBF ,0xE3 ,0x7F ,0xE1 ,0xFF ,0xFE ,0x1 ,0xE0 ,0x1E ,0x52 ,0x20 ,0x0 ,0x0 ,0x7 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xF ,0x86 ,0x0 ,0x0 ,0x1 ,0xBF ,0xE7 ,0xBF ,0xE3 ,0xFC ,0xFF ,0x1 ,0xE0 ,0xF ,0x12 ,0xE0 ,0x0 ,0x0 ,0x9 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1F ,0xFC ,0x0 ,0x0 ,0x1 ,0xBF ,0xC3 ,0x3F ,0xE3 ,0xF0 ,0xFF ,0x1 ,0x9C ,0x0 ,0xFF ,0x0 ,0x0 ,0x0 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3F ,0xF8 ,0x0 ,0x0 ,0x1 ,0x87 ,0xE0 ,0x7F ,0x7 ,0xE0 ,0x7F ,0x81 ,0x9E ,0x0 ,0x7E ,0x8 ,0x0 ,0x0 ,0x61 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7F ,0xF0 ,0x0 ,0x0 ,0x1 ,0x83 ,0xF8 ,0x7F ,0xF ,0x80 ,0x3F ,0x81 ,0x87 ,0x80 ,0x18 ,0x4 ,0x0 ,0x0 ,0x81 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xFF ,0xE0 ,0x0 ,0x0 ,0x1 ,0x83 ,0xFF ,0xFE ,0xF ,0x0 ,0x3F ,0xC1 ,0x81 ,0xC0 ,0x10 ,0x6 ,0x0 ,0x3 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0xFF ,0xC0 ,0x0 ,0x0 ,0x1 ,0x81 ,0xFF ,0xFE ,0xF ,0x0 ,0x3F ,0xC1 ,0x80 ,0xE0 ,0x10 ,0x39 ,0x0 ,0x4 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x3 ,0xFF ,0x80 ,0x0 ,0x0 ,0x1 ,0xF8 ,0x0 ,0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x38 ,0x10 ,0xC1 ,0xC0 ,0x18 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xFF ,0x0 ,0x0 ,0x0 ,0x1 ,0xF0 ,0x0 ,0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x1C ,0x10 ,0x41 ,0xF8 ,0x38 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0xF ,0xFE ,0x0 ,0x0 ,0x0 ,0x1 ,0xF8 ,0x70 ,0x70 ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x3 ,0x90 ,0xE0 ,0xFF ,0xF4 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0xF ,0xFC ,0x0 ,0x0 ,0x0 ,0x1 ,0xFC ,0xF0 ,0x79 ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x1 ,0xD1 ,0xF0 ,0x3F ,0x81 ,0x81 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0xF ,0xF8 ,0x0 ,0x0 ,0x0 ,0x1 ,0xFF ,0xF0 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x77 ,0x8 ,0x1F ,0x0 ,0x41 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x1F ,0xF0 ,0x0 ,0x0 ,0x0 ,0x1 ,0xFF ,0xF0 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x7F ,0x8 ,0xE ,0x0 ,0x21 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0xE0 ,0x0 ,0x0 ,0x0 ,0x1 ,0xFF ,0xF0 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x18 ,0x4 ,0x4 ,0x0 ,0x11 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0xC0 ,0x0 ,0x0 ,0x0 ,0x1 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x0 ,0x2 ,0x0 ,0x0 ,0x9 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x1E ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x0 ,0x2 ,0x0 ,0x0 ,0x5 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0xC ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x3 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x80 ,0x0 ,0xD ,0x8F ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xF1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x40 ,0x0 ,0x71 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x9F ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x88 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9F ,0x0 ,0x0 ,0x0 ,0x20 ,0x1 ,0x81 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x90 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x90 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x81 ,0x0 ,0x0 ,0x0 ,0x10 ,0x6 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x9E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x90 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x8 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x0 ,0x0 ,0x4 ,0x18 ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x0 ,0x0 ,0x1 ,0xC0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,
	};
	send_data(addr & 0xFF);
	send_data(addr >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i <1680; i++  ){
		send_data(desenho[i]);
	}
	send_command(Auto_reset);
	status(2);

	escrita_texto(0x9, "CONFIGURA", sizeof("CONFIGURA"));
	EscreveCedilhaAOTil();

}

void desenho_configuracao3( void ){

	unsigned int addr = 0x780;
	unsigned char desenho[] = {
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x1F ,0xC0 ,0x0 ,0x3 ,0xFE ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0xE0 ,0x0 ,0x2 ,0x7F ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0xF0 ,0x0 ,0x4 ,0xFF ,0x81 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0xF8 ,0x0 ,0xE ,0xFF ,0x81 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0xFC ,0x0 ,0x1F ,0xFF ,0x81 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0xFE ,0x0 ,0x1F ,0xFF ,0xC1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xFF ,0xFC ,0x0 ,0x3 ,0xFF ,0xC1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xDF ,0x8F ,0xFF ,0xFE ,0x7F ,0x81 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xDF ,0xBF ,0xF9 ,0xFF ,0x3F ,0x81 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x5E ,0x7F ,0x0 ,0xF ,0xC7 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x7E ,0x7F ,0x0 ,0x7 ,0xE7 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3C ,0xFC ,0x0 ,0x3 ,0xF7 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x31 ,0xE1 ,0xFF ,0xF0 ,0xFE ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xF ,0x9F ,0xF9 ,0xFE ,0x3C ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x1F ,0x9F ,0xF9 ,0xFF ,0xE ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0x3F ,0xF9 ,0xFF ,0x86 ,0x1 ,0x80 ,0x0 ,0x7E ,0x0 ,0xFE ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3E ,0x7F ,0xF9 ,0xE7 ,0xC7 ,0x1 ,0x80 ,0x0 ,0x7E ,0x0 ,0xFE ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3E ,0xFF ,0xF9 ,0xEF ,0xC7 ,0x1 ,0x80 ,0x0 ,0xE1 ,0x83 ,0x7 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3E ,0xFF ,0xF9 ,0xDF ,0xE7 ,0x1 ,0x80 ,0x0 ,0xE1 ,0x83 ,0x7 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3D ,0xFF ,0xFF ,0x9F ,0xF7 ,0x81 ,0x80 ,0xF ,0x0 ,0x64 ,0x0 ,0x70 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x7B ,0xFF ,0xFF ,0x7F ,0xFB ,0xC1 ,0x80 ,0x3C ,0x0 ,0x18 ,0x0 ,0x1C ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x73 ,0xFF ,0xFE ,0x7F ,0xFB ,0xE1 ,0x80 ,0x3C ,0x0 ,0x18 ,0x0 ,0x1C ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xF3 ,0xFF ,0xFE ,0x7F ,0xF9 ,0xE1 ,0x81 ,0xC0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xC1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xF3 ,0xFF ,0xFE ,0xFF ,0xF9 ,0xE1 ,0x81 ,0xC0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xC1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xF3 ,0xFF ,0xFF ,0xFF ,0x19 ,0xE1 ,0x9E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x21 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xF3 ,0xFF ,0xF9 ,0xFE ,0x9 ,0xE1 ,0x9E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x21 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xF3 ,0xFF ,0xF9 ,0xFF ,0x19 ,0xE1 ,0xA0 ,0x7F ,0x80 ,0x0 ,0x7 ,0xFF ,0xF9 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xF3 ,0xFF ,0xFE ,0xFF ,0xF9 ,0xE1 ,0xA0 ,0x0 ,0x7F ,0xC1 ,0xFE ,0x0 ,0x19 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xF3 ,0xFF ,0xFE ,0xFF ,0xF9 ,0xE1 ,0xA0 ,0x0 ,0x7F ,0xC1 ,0xFE ,0x0 ,0x19 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xFB ,0xFF ,0xFE ,0x7F ,0xF9 ,0xE1 ,0x98 ,0x0 ,0x0 ,0xFF ,0x80 ,0x0 ,0x19 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xFD ,0xFF ,0xFF ,0x7F ,0xFB ,0xE1 ,0x98 ,0x0 ,0x0 ,0xFF ,0x80 ,0x0 ,0x19 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x7D ,0xFF ,0xFF ,0x3F ,0xFB ,0xE1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x21 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x7C ,0xFF ,0xFF ,0x3F ,0xFB ,0xE1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x21 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x7C ,0x7F ,0xFF ,0xDF ,0xF7 ,0xC1 ,0x81 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0xC1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0x7F ,0xFC ,0xFF ,0xE7 ,0x81 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0x3 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0x3F ,0xFC ,0xFF ,0xC7 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0x3 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0xBF ,0xFC ,0xFF ,0x8F ,0x1 ,0x80 ,0x3C ,0x0 ,0x0 ,0x0 ,0xC ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0xBF ,0xFC ,0xFF ,0x1F ,0x1 ,0x80 ,0x3C ,0x0 ,0x0 ,0x0 ,0xC ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0x9F ,0xFD ,0xFE ,0x3E ,0x1 ,0x80 ,0xF ,0x0 ,0x0 ,0x0 ,0x70 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x1F ,0xC1 ,0xFF ,0xFC ,0x78 ,0x1 ,0x80 ,0xF ,0x0 ,0x0 ,0x0 ,0x70 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xFC ,0x0 ,0x1 ,0xF8 ,0x1 ,0x80 ,0x0 ,0xE0 ,0x0 ,0x7 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0xFF ,0x0 ,0x7 ,0xF8 ,0x1 ,0x80 ,0x0 ,0x1F ,0xFF ,0xF8 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x1E ,0xFF ,0xE0 ,0xFF ,0xC6 ,0x1 ,0x80 ,0x0 ,0x1F ,0xFF ,0xF8 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0x7F ,0xFF ,0xFF ,0x8E ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x8E ,0x3F ,0x7F ,0xFF ,0xFF ,0x8E ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x91 ,0x3E ,0x3F ,0xFF ,0xFC ,0xE ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x91 ,0x3C ,0xF ,0xFF ,0xFC ,0x6 ,0x1 ,0x93 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x8F ,0x0 ,0x0 ,0x0 ,0x0 ,0x6 ,0x1 ,0x95 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x99 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x8C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,

	};
	send_data(addr & 0xFF);
	send_data(addr >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i <1680; i++  ){
		send_data(desenho[i]);
	}
	send_command(Auto_reset);
	status(2);

	escrita_texto(0x9, "CONFIGURA", sizeof("CONFIGURA"));
	EscreveCedilhaAOTil();

}

void desenho_servicos1( void ){

	unsigned int addr = 0x780;
	unsigned char desenho[] = {
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3F ,0x1F ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xC0 ,0x0 ,0xF8 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0x80 ,0x0 ,0x3C ,0x0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0x0 ,0x11 ,0x80 ,0x1C ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3 ,0x0 ,0x0 ,0x4C ,0x0 ,0x1 ,0x80 ,0xE0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x21 ,0x80 ,0x1F ,0x80 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0xE ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x6 ,0x3 ,0xFC ,0x64 ,0x0 ,0x1 ,0x81 ,0x50 ,0x0 ,0x0 ,0x0 ,0x0 ,0x41 ,0x80 ,0x7 ,0xE0 ,0x0 ,0x7C ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0xFF ,0xFE ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0xC ,0xF ,0xFE ,0x3A ,0x0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0x2 ,0x81 ,0x80 ,0x0 ,0xF0 ,0x0 ,0x3F ,0x0 ,0x1 ,0x80 ,0x0 ,0x7 ,0xFF ,0xFF ,0xF8 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x18 ,0x3F ,0xFF ,0xE ,0x0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0x3 ,0x1 ,0x80 ,0x1 ,0xF0 ,0x0 ,0x3 ,0x80 ,0x1 ,0x80 ,0x0 ,0x3F ,0xEE ,0x3F ,0xF8 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x18 ,0x70 ,0xF ,0x85 ,0x0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0xF ,0x81 ,0x80 ,0x3 ,0xE0 ,0x0 ,0x1 ,0xE0 ,0x1 ,0x80 ,0x0 ,0xFF ,0xFF ,0xF8 ,0x7C ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x20 ,0x1F ,0x1 ,0xE3 ,0x0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0x6 ,0x1 ,0x80 ,0xF ,0x60 ,0x0 ,0x0 ,0x70 ,0x1 ,0x80 ,0x7 ,0xBF ,0xFF ,0xFF ,0xF7 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x60 ,0x7F ,0xE0 ,0xE3 ,0x80 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0xA ,0x1 ,0x80 ,0x1E ,0x60 ,0x0 ,0x0 ,0x38 ,0x1 ,0x80 ,0xF ,0x7F ,0xFF ,0xFF ,0xFF ,0x81 ,0x0 ,
			0x0 ,0x80 ,0x60 ,0x7F ,0xE0 ,0x73 ,0x80 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0x10 ,0x1 ,0x80 ,0x38 ,0x60 ,0x0 ,0x0 ,0x18 ,0x1 ,0x80 ,0x1C ,0xC3 ,0xFF ,0xFF ,0xFB ,0xC1 ,0x0 ,
			0x0 ,0x80 ,0x60 ,0x80 ,0xF8 ,0x73 ,0xC0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0x20 ,0x1 ,0x80 ,0x30 ,0x60 ,0x0 ,0x0 ,0x1C ,0x1 ,0x80 ,0x3B ,0x87 ,0xFF ,0xFF ,0xFD ,0xE1 ,0x0 ,
			0x0 ,0x80 ,0xE1 ,0x0 ,0x1C ,0x33 ,0xC0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0x40 ,0x1 ,0x80 ,0x70 ,0x60 ,0x0 ,0x0 ,0xE ,0x1 ,0x80 ,0x77 ,0xBF ,0xFF ,0xF8 ,0x3E ,0xF1 ,0x0 ,
			0x0 ,0x80 ,0xE0 ,0x0 ,0xE ,0x33 ,0xC0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0x80 ,0x1 ,0x80 ,0xE0 ,0x60 ,0x0 ,0x0 ,0x7 ,0x1 ,0x80 ,0xEF ,0xFF ,0xFF ,0xE3 ,0x9E ,0x71 ,0x0 ,
			0x0 ,0x80 ,0xE0 ,0x0 ,0x6 ,0x33 ,0xC0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x1 ,0x0 ,0x1 ,0x80 ,0xC0 ,0x60 ,0x0 ,0x0 ,0x3 ,0x1 ,0x81 ,0xDF ,0xFF ,0xFF ,0xE3 ,0x9F ,0x79 ,0x0 ,
			0x0 ,0x80 ,0xE0 ,0x0 ,0x0 ,0x33 ,0xC0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x2 ,0x0 ,0x1 ,0x81 ,0xC0 ,0x0 ,0x0 ,0x0 ,0x3 ,0x81 ,0x87 ,0x3F ,0xFF ,0xE0 ,0xF3 ,0x9F ,0xDD ,0x0 ,
			0x0 ,0x80 ,0xE0 ,0x0 ,0x0 ,0x23 ,0xD0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x4 ,0x0 ,0x1 ,0x83 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0xC1 ,0x8E ,0x7F ,0xFF ,0x86 ,0x70 ,0x3F ,0xDF ,0x0 ,
			0x0 ,0x80 ,0xE0 ,0x0 ,0x0 ,0x23 ,0x90 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x8 ,0x0 ,0x1 ,0x83 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xC1 ,0x9C ,0xFF ,0xFC ,0x9E ,0x38 ,0xFF ,0xEF ,0x0 ,
			0x0 ,0x80 ,0xE0 ,0x0 ,0x0 ,0x23 ,0xB0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x10 ,0x0 ,0x1 ,0x83 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xC1 ,0x9B ,0xFF ,0xE0 ,0x1F ,0x38 ,0xFF ,0xEF ,0x0 ,
			0x0 ,0x80 ,0x60 ,0x0 ,0x0 ,0x3 ,0xB0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x20 ,0x0 ,0x1 ,0x83 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xC1 ,0xB7 ,0xFF ,0x83 ,0x1F ,0x3C ,0x7F ,0xFF ,0x0 ,
			0x0 ,0x80 ,0x60 ,0x0 ,0x0 ,0x3 ,0x20 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x40 ,0x0 ,0x1 ,0x83 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xC1 ,0xB7 ,0xE3 ,0xA7 ,0x1F ,0x9C ,0x7F ,0xEF ,0x0 ,
			0x0 ,0x80 ,0x30 ,0x0 ,0x0 ,0x3 ,0x20 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x80 ,0x0 ,0x1 ,0x87 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x61 ,0xB7 ,0xC1 ,0xE7 ,0x9F ,0x9C ,0x3F ,0xEF ,0x0 ,
			0x0 ,0x80 ,0x1C ,0x0 ,0x0 ,0xC ,0x60 ,0x1 ,0x80 ,0x40 ,0x0 ,0x1 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x61 ,0xA7 ,0x9F ,0xF3 ,0x8F ,0x1E ,0x7F ,0xDD ,0x0 ,
			0x0 ,0x80 ,0x3E ,0x0 ,0x0 ,0x1C ,0xC0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x2 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x61 ,0xE7 ,0x9F ,0xF3 ,0xC6 ,0x3F ,0xFF ,0xBD ,0x0 ,
			0x0 ,0x80 ,0x2F ,0x0 ,0x0 ,0x3C ,0xC0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x4 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x61 ,0xE7 ,0xC1 ,0xF3 ,0xC0 ,0x3F ,0xFF ,0xB9 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xC0 ,0x0 ,0x71 ,0xC0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x8 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x61 ,0xE7 ,0xE0 ,0xF1 ,0xE0 ,0xFF ,0xFF ,0x39 ,0x0 ,
			0x0 ,0x80 ,0x11 ,0xF0 ,0x1 ,0xE3 ,0x80 ,0x1 ,0x80 ,0x40 ,0x0 ,0x10 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x61 ,0xE7 ,0xFC ,0xF9 ,0xFF ,0xFF ,0xCF ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x18 ,0x7E ,0x3 ,0x83 ,0x0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x20 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x61 ,0xE7 ,0xFC ,0xF9 ,0xFF ,0xFF ,0xCE ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x8 ,0x3F ,0xFE ,0xFE ,0x0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x40 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x61 ,0xE7 ,0xFC ,0xFF ,0xFF ,0xFF ,0xDE ,0xF1 ,0x0 ,
			0x0 ,0x80 ,0x3 ,0xC0 ,0x1 ,0x8 ,0x0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x80 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xE1 ,0xF7 ,0x0 ,0xFF ,0xFF ,0xFF ,0x9D ,0xE1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xE0 ,0x1 ,0x4 ,0x0 ,0x1 ,0x80 ,0x40 ,0x1 ,0x0 ,0x0 ,0x0 ,0x1 ,0x83 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xC1 ,0xF7 ,0x80 ,0xFF ,0xFF ,0xFF ,0x1B ,0xE1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3F ,0xFF ,0x0 ,0x0 ,0x1 ,0x80 ,0x40 ,0x2 ,0x0 ,0x0 ,0x0 ,0x1 ,0x83 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xC1 ,0xF7 ,0xC3 ,0xFF ,0xFF ,0xFC ,0x1B ,0xC1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFE ,0x2 ,0x0 ,0x1 ,0x80 ,0x40 ,0x4 ,0x0 ,0x0 ,0x0 ,0x1 ,0x83 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xC1 ,0xF7 ,0xFF ,0xFF ,0xFF ,0xFC ,0x3F ,0xC1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x83 ,0x0 ,0x1 ,0x80 ,0x40 ,0x8 ,0x0 ,0x0 ,0x0 ,0x1 ,0x83 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xC1 ,0xF7 ,0xFF ,0xFF ,0xFF ,0xFC ,0x77 ,0x81 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x83 ,0x80 ,0x1 ,0x80 ,0x40 ,0x10 ,0x0 ,0x0 ,0x0 ,0x1 ,0x83 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0xC1 ,0xF7 ,0xFF ,0xFF ,0xFF ,0xFF ,0xF7 ,0x81 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x41 ,0x80 ,0x1 ,0x80 ,0x40 ,0x20 ,0x0 ,0x0 ,0x0 ,0x1 ,0x81 ,0xC0 ,0x0 ,0x0 ,0x6 ,0x3 ,0x81 ,0xB3 ,0xFF ,0xFF ,0xFF ,0xFF ,0xC7 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x20 ,0xE0 ,0x1 ,0x80 ,0x42 ,0x40 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0xC0 ,0x0 ,0x0 ,0x6 ,0x3 ,0x1 ,0xBE ,0x7F ,0xFF ,0xFF ,0xFC ,0x7E ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x20 ,0xF0 ,0x1 ,0x80 ,0x42 ,0x80 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0xE0 ,0x0 ,0x0 ,0x6 ,0x7 ,0x1 ,0x9F ,0x3F ,0xFF ,0xFF ,0xF1 ,0xFC ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x30 ,0x70 ,0x1 ,0x80 ,0x43 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x70 ,0x0 ,0x0 ,0x6 ,0xE ,0x1 ,0x8F ,0xCF ,0xFF ,0xFF ,0x87 ,0xF8 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x10 ,0x38 ,0x1 ,0x80 ,0x4F ,0x80 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x38 ,0x0 ,0x0 ,0x6 ,0x1C ,0x1 ,0x87 ,0xE3 ,0xFF ,0xFE ,0x3F ,0xF0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x10 ,0x38 ,0x1 ,0x80 ,0x46 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x18 ,0x0 ,0x0 ,0x6 ,0x78 ,0x1 ,0x81 ,0xF8 ,0xFF ,0xF0 ,0xFF ,0xC0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x18 ,0x18 ,0x1 ,0x80 ,0x4A ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x1C ,0x0 ,0x0 ,0x6 ,0xF0 ,0x1 ,0x80 ,0xFE ,0x7F ,0xC3 ,0xFE ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x18 ,0xC ,0x1 ,0x80 ,0x50 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0xE ,0x0 ,0x0 ,0x7 ,0xC0 ,0x1 ,0x80 ,0x3F ,0x9F ,0x1F ,0xF8 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x4 ,0xC7 ,0x1 ,0x80 ,0x60 ,0x0 ,0x0 ,0x0 ,0x0 ,0x21 ,0x80 ,0x7 ,0x80 ,0x0 ,0xF ,0x80 ,0x1 ,0x80 ,0x7 ,0xF3 ,0xFE ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x7 ,0x83 ,0x81 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0x0 ,0x11 ,0x80 ,0x1 ,0xC0 ,0x0 ,0xF ,0x0 ,0x1 ,0x80 ,0x1 ,0xFF ,0xF8 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x7 ,0x1 ,0x81 ,0x80 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0xF9 ,0x80 ,0x0 ,0xFC ,0x0 ,0x7 ,0xE0 ,0x1 ,0x80 ,0x0 ,0xFF ,0x80 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x0 ,0x0 ,0x2 ,0x3E ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x11 ,0x9F ,0x0 ,0x3E ,0x0 ,0x1 ,0xF8 ,0x1 ,0x82 ,0x0 ,0x3C ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x8C ,0x0 ,0x0 ,0x0 ,0x2 ,0x66 ,0x41 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x21 ,0x82 ,0x0 ,0x2 ,0x0 ,0x0 ,0x38 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x0 ,0x0 ,0x2 ,0xC0 ,0x41 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8A ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x0 ,0x0 ,0x3 ,0x80 ,0xC1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x92 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x0 ,0x0 ,0x3 ,0x83 ,0x81 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9F ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x0 ,0x0 ,0x1 ,0xC7 ,0x81 ,0x88 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x8E ,0x0 ,0x0 ,0x0 ,0x1 ,0xFF ,0x1 ,0x9F ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,

	};
	send_data(addr & 0xFF);
	send_data(addr >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i <1680; i++  ){
		send_data(desenho[i]);
	}
	send_command(Auto_reset);
	status(2);

	escrita_texto(0xB, "SERVI", sizeof("SERVI"));
	send_data(0x60);
	send_command(0xC0);
	status(1);
	send_data(0x2F);
	send_command(0xC0);
	status(1);

}

void desenho_servicos2( void ){

	unsigned int addr = 0x780;
	unsigned char desenho[] = {
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xF ,0xFF ,0xE0 ,0x60 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x1F ,0xFF ,0xF8 ,0x60 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xFC ,0x3 ,0xFE ,0x60 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x1 ,0xF0 ,0x0 ,0xF ,0x60 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x1 ,0xC0 ,0x0 ,0x7 ,0x60 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x3 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x1 ,0x80 ,0x0 ,0xF3 ,0xE0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0xE ,0xC0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0xFF ,0xC0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x38 ,0x40 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x1F ,0xC0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x1 ,0xC0 ,0x40 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x1E ,0x20 ,0x20 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x81 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x78 ,0x30 ,0x20 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x18 ,0x0 ,0x0 ,0x0 ,0x6 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x1 ,0xC0 ,0x30 ,0x30 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0x0 ,0x0 ,0x0 ,0x1C ,0x1 ,0x80 ,0x7F ,0xFF ,0xC0 ,0x1F ,0xFF ,0xF1 ,0x80 ,0x0 ,0xF ,0x0 ,0x10 ,0x10 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0xC0 ,0x0 ,0x0 ,0x30 ,0x1 ,0x81 ,0x80 ,0x0 ,0xC0 ,0x60 ,0x0 ,0x31 ,0x80 ,0x0 ,0x78 ,0x0 ,0x18 ,0x10 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x60 ,0x0 ,0x0 ,0xC0 ,0x1 ,0x86 ,0x0 ,0x1 ,0x41 ,0x80 ,0x0 ,0x51 ,0x80 ,0x1 ,0xE0 ,0x0 ,0x18 ,0x18 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x38 ,0x0 ,0x3 ,0xC0 ,0x1 ,0x8F ,0xFF ,0xFE ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x3B ,0x80 ,0x0 ,0x8 ,0x8 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x44 ,0x0 ,0x6 ,0x40 ,0x1 ,0x88 ,0x0 ,0x2 ,0x42 ,0x0 ,0x0 ,0x91 ,0x80 ,0x4C ,0xFC ,0x0 ,0xC ,0x8 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x42 ,0x0 ,0x8 ,0x40 ,0x1 ,0x88 ,0x0 ,0x2 ,0x42 ,0x0 ,0x0 ,0x91 ,0x80 ,0x4C ,0x4 ,0x0 ,0x4 ,0x4 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xC7 ,0x80 ,0x8 ,0x20 ,0x1 ,0x88 ,0x0 ,0x2 ,0x42 ,0x0 ,0x0 ,0x91 ,0x80 ,0xC4 ,0x4 ,0x0 ,0x4 ,0x4 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x84 ,0xF0 ,0x7C ,0x30 ,0x1 ,0x8B ,0xBB ,0xBA ,0x42 ,0xEE ,0xEE ,0x91 ,0x80 ,0x86 ,0x46 ,0x0 ,0xC ,0x4 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x8C ,0xF ,0xC6 ,0x10 ,0x1 ,0x8A ,0xAA ,0xAA ,0x42 ,0xAA ,0xAA ,0x91 ,0x81 ,0x86 ,0x42 ,0x0 ,0x38 ,0x6 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0x8 ,0xE ,0x2 ,0x18 ,0x1 ,0x8B ,0xBB ,0xBA ,0x42 ,0xEE ,0xEE ,0x91 ,0x81 ,0x82 ,0x62 ,0x0 ,0xF8 ,0x2 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0x8 ,0x30 ,0x2 ,0x8 ,0x1 ,0x88 ,0x0 ,0x2 ,0x42 ,0x0 ,0x0 ,0x91 ,0x83 ,0x3 ,0x63 ,0x3 ,0xC0 ,0x2 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x2 ,0x10 ,0x60 ,0x1 ,0xC ,0x1 ,0x88 ,0x0 ,0x2 ,0x42 ,0x0 ,0x0 ,0x91 ,0x81 ,0x1 ,0x38 ,0x7C ,0x0 ,0x1 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x2 ,0x10 ,0x80 ,0x1 ,0x84 ,0x1 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x81 ,0x81 ,0x81 ,0xE0 ,0x0 ,0x1 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x4 ,0x31 ,0x0 ,0x0 ,0x82 ,0x1 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x81 ,0x81 ,0x87 ,0x7 ,0x0 ,0x1 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x4 ,0x21 ,0x40 ,0x0 ,0xC3 ,0x1 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x81 ,0xFC ,0x1F ,0xC0 ,0x0 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x8 ,0x61 ,0x40 ,0x0 ,0x41 ,0x1 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0xC0 ,0xF8 ,0x38 ,0xE0 ,0x0 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x8 ,0x41 ,0x1 ,0xC0 ,0x61 ,0x81 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0xC0 ,0x0 ,0x60 ,0x30 ,0x0 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x18 ,0xC0 ,0xFE ,0x30 ,0x30 ,0xC1 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x40 ,0x0 ,0xC0 ,0x18 ,0x0 ,0xC1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x10 ,0x80 ,0x0 ,0x8 ,0x10 ,0x41 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x0 ,0x0 ,0x82 ,0x18 ,0x0 ,0x41 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x30 ,0x80 ,0x0 ,0x6 ,0x8 ,0x61 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x20 ,0x0 ,0x82 ,0x8 ,0x0 ,0x61 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x8C ,0x21 ,0x0 ,0x0 ,0x1 ,0xC ,0x31 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x20 ,0x0 ,0x80 ,0x8 ,0x0 ,0x31 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x61 ,0x0 ,0x0 ,0x0 ,0x86 ,0x11 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x30 ,0x0 ,0x80 ,0x18 ,0x0 ,0x31 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x42 ,0x0 ,0x0 ,0x80 ,0x43 ,0x19 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x30 ,0x0 ,0x80 ,0x18 ,0x0 ,0x31 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0xC0 ,0x86 ,0x0 ,0x0 ,0xE0 ,0x33 ,0xFF ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x30 ,0x0 ,0xC0 ,0x30 ,0x0 ,0x11 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0xF8 ,0xC6 ,0x0 ,0x0 ,0x38 ,0x17 ,0xE7 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x18 ,0x0 ,0x60 ,0x60 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x9F ,0xF9 ,0x0 ,0x0 ,0xE ,0x1C ,0x1 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0xC ,0x0 ,0xF ,0x0 ,0x0 ,0x9 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x81 ,0xB ,0x9C ,0x3 ,0x1 ,0xF0 ,0x1 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0xC ,0x0 ,0x0 ,0x0 ,0x0 ,0xD ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x2 ,0x61 ,0x80 ,0xC0 ,0x60 ,0x1 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0xC ,0x0 ,0x0 ,0x0 ,0x0 ,0xD ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x22 ,0x40 ,0x38 ,0x60 ,0x1 ,0x8F ,0xFF ,0xFE ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x6 ,0x0 ,0x0 ,0x0 ,0x0 ,0xD ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x4 ,0x22 ,0x6 ,0x7 ,0xC0 ,0x1 ,0x8F ,0xFF ,0xFE ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x6 ,0x0 ,0x0 ,0x0 ,0x0 ,0x3D ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x4 ,0x62 ,0x23 ,0x82 ,0x0 ,0x1 ,0x8F ,0xFF ,0xFE ,0x83 ,0xFF ,0xFF ,0xA1 ,0x80 ,0x2 ,0x0 ,0x0 ,0x0 ,0x1 ,0xF1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x2 ,0x62 ,0x48 ,0x3E ,0x0 ,0x1 ,0x8F ,0xFF ,0xFF ,0x3 ,0xFF ,0xFF ,0xC1 ,0x80 ,0x3 ,0x0 ,0x0 ,0x0 ,0x7 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0x9E ,0x4 ,0x30 ,0x0 ,0x1 ,0x8F ,0xFF ,0xFE ,0x3 ,0xFF ,0xFF ,0x81 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0xF8 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x43 ,0xE0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x1 ,0x80 ,0x0 ,0x3 ,0xC0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x9F ,0x0 ,0x0 ,0xE6 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9F ,0x1 ,0x80 ,0x0 ,0xF ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x90 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x88 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x81 ,0x0 ,0x80 ,0x0 ,0x7C ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x9E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x90 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x80 ,0x1 ,0xE0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x98 ,0x1F ,0x80 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x43 ,0xC0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x67 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x7C ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,

	};
	send_data(addr & 0xFF);
	send_data(addr >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i <1680; i++  ){
		send_data(desenho[i]);
	}
	send_command(Auto_reset);
	status(2);

	escrita_texto(0xB, "SERVI", sizeof("SERVI"));
	send_data(0x60);
	send_command(0xC0);
	status(1);
	send_data(0x2F);
	send_command(0xC0);
	status(1);

}

void desenho_inicializacao( void ){

	unsigned int addr = 0x780;
	unsigned char desenho[] = {
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xFF ,0xE0 ,0xFF ,0xFF ,0xFF ,0xF8 ,0xF ,0xFF ,0xFC ,0x1 ,0xFF ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xFF ,0xC0 ,0xFF ,0xFF ,0xFF ,0xFC ,0xF ,0xFF ,0xFC ,0x1 ,0xFF ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xFF ,0xC1 ,0xFF ,0xFF ,0xFF ,0xFE ,0xF ,0xFF ,0xFC ,0x1 ,0xFF ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7 ,0xFF ,0xC3 ,0xFF ,0xFF ,0xFF ,0xFE ,0x1F ,0xFF ,0xFC ,0x3 ,0xFF ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7 ,0xFF ,0xC7 ,0xFF ,0xFF ,0xFF ,0xFE ,0x1F ,0xFF ,0xFC ,0x3 ,0xFE ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7 ,0xFF ,0xC7 ,0xFF ,0xFF ,0xFF ,0xFE ,0x1F ,0xFF ,0xFC ,0x3 ,0xFE ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xF ,0xFF ,0x8F ,0xFF ,0x80 ,0x3F ,0xFF ,0x1F ,0xFF ,0xFE ,0x7 ,0xFE ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xF ,0xFF ,0x8F ,0xFF ,0x80 ,0x3F ,0xFE ,0x1F ,0xFF ,0xFE ,0x7 ,0xFE ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFF ,0x80 ,0x0 ,0xFF ,0xE0 ,0x0 ,0x1F ,0xC0 ,0x0 ,0xFF ,0x0 ,0xF ,0xF0 ,0x0 ,0xF ,0xFF ,0x8F ,0xFF ,0x80 ,0x3F ,0xFE ,0x1F ,0xFF ,0xFF ,0x7 ,0xFC ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFF ,0x80 ,0x0 ,0xFF ,0xE0 ,0x0 ,0x1F ,0xC0 ,0x0 ,0xFF ,0x0 ,0x1F ,0xF0 ,0x0 ,0xF ,0xFF ,0x8F ,0xFF ,0x0 ,0x7F ,0xFE ,0x1F ,0xFF ,0xFF ,0xF ,0xFC ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFF ,0xC0 ,0x0 ,0xFF ,0xE0 ,0x0 ,0x3F ,0xE0 ,0x0 ,0xFF ,0x80 ,0x1F ,0xE0 ,0x0 ,0xF ,0xFF ,0x8F ,0xFF ,0x0 ,0x7F ,0xFE ,0x3F ,0xFF ,0xFF ,0xF ,0xFC ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFF ,0xC0 ,0x0 ,0xFF ,0xE0 ,0x0 ,0x7F ,0xE0 ,0x0 ,0x7F ,0x80 ,0x1F ,0xC0 ,0x0 ,0xF ,0xFF ,0x9F ,0xFF ,0x0 ,0x7F ,0xFE ,0x3F ,0xFF ,0xFF ,0x8F ,0xFC ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFF ,0xE0 ,0x1 ,0xFF ,0xE0 ,0x0 ,0x7F ,0xE0 ,0x0 ,0x3F ,0xC0 ,0x3F ,0x80 ,0x0 ,0xF ,0xFF ,0x9F ,0xFF ,0x0 ,0x7F ,0xFE ,0x3F ,0xFF ,0xFF ,0x8F ,0xFC ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFF ,0xE0 ,0x1 ,0xFF ,0xE0 ,0x0 ,0x7F ,0xF0 ,0x0 ,0x1F ,0xE0 ,0x7F ,0x80 ,0x0 ,0xF ,0xFF ,0x1F ,0xFE ,0x0 ,0x7F ,0xFE ,0x7F ,0xFF ,0xFF ,0x8F ,0xFC ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFF ,0xE0 ,0x3 ,0xFF ,0xE0 ,0x0 ,0x7F ,0xF0 ,0x0 ,0x1F ,0xE0 ,0xFF ,0x80 ,0x0 ,0x1F ,0xFF ,0x1F ,0xFE ,0x0 ,0x7F ,0xFE ,0x7F ,0xFF ,0xFF ,0x8F ,0xFC ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFF ,0xE0 ,0x3 ,0xFF ,0xE0 ,0x0 ,0xFF ,0xF0 ,0x0 ,0x1F ,0xF0 ,0xFF ,0x0 ,0x0 ,0x1F ,0xFF ,0x3F ,0xFE ,0x0 ,0x7F ,0xFE ,0x7F ,0xFF ,0xFF ,0x8F ,0xFC ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFF ,0xF0 ,0x3 ,0xEF ,0xE0 ,0x0 ,0xFD ,0xF8 ,0x0 ,0xF ,0xF0 ,0xFE ,0x0 ,0x0 ,0x1F ,0xFF ,0x3F ,0xFE ,0x0 ,0x7F ,0xFC ,0x7F ,0xFF ,0xFF ,0x9F ,0xF8 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFF ,0xF0 ,0x3 ,0xEF ,0xE0 ,0x1 ,0xFD ,0xFC ,0x0 ,0x7 ,0xF8 ,0xFC ,0x0 ,0x0 ,0x1F ,0xFF ,0x3F ,0xFE ,0x0 ,0xFF ,0xFC ,0x7F ,0xF7 ,0xFF ,0xDF ,0xF8 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFF ,0xF0 ,0x3 ,0xEF ,0xE0 ,0x1 ,0xFD ,0xFC ,0x0 ,0x3 ,0xF9 ,0xFC ,0x0 ,0x0 ,0x1F ,0xFE ,0x3F ,0xFC ,0x0 ,0xFF ,0xFC ,0x7F ,0xE7 ,0xFF ,0xDF ,0xF8 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFD ,0xF8 ,0x7 ,0xEF ,0xE0 ,0x3 ,0xF8 ,0xFC ,0x0 ,0x3 ,0xFF ,0xF8 ,0x0 ,0x0 ,0x3F ,0xFE ,0x7F ,0xFC ,0x0 ,0xFF ,0xFC ,0x7F ,0xE7 ,0xFF ,0xDF ,0xF0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFD ,0xF8 ,0x7 ,0xEF ,0xE0 ,0x3 ,0xF8 ,0xFC ,0x0 ,0x3 ,0xFF ,0xF0 ,0x0 ,0x0 ,0x3F ,0xFE ,0x7F ,0xFC ,0x0 ,0xFF ,0xF8 ,0xFF ,0xE3 ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0xFC ,0xF ,0xCF ,0xE0 ,0x7 ,0xF0 ,0xFE ,0x0 ,0x0 ,0xFF ,0xE0 ,0x0 ,0x0 ,0x3F ,0xFC ,0x7F ,0xFC ,0x0 ,0xFF ,0xF8 ,0xFF ,0xC3 ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0xFC ,0xF ,0x8F ,0xE0 ,0x7 ,0xF0 ,0xFF ,0x0 ,0x0 ,0x7F ,0xE0 ,0x0 ,0x0 ,0x7F ,0xFC ,0x7F ,0xFC ,0x0 ,0xFF ,0xF8 ,0xFF ,0xC1 ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0xFC ,0x1F ,0x8F ,0xE0 ,0x7 ,0xE0 ,0xFF ,0x0 ,0x0 ,0x7F ,0xC0 ,0x0 ,0x0 ,0x7F ,0xFC ,0x7F ,0xFC ,0x0 ,0xFF ,0xF8 ,0xFF ,0xC1 ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0xFC ,0x1F ,0xF ,0xE0 ,0xF ,0xE0 ,0x7F ,0x80 ,0x0 ,0x7F ,0xE0 ,0x0 ,0x0 ,0x7F ,0xFC ,0x7F ,0xFC ,0x1 ,0xFF ,0xF0 ,0xFF ,0x81 ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0xFE ,0x1F ,0xF ,0xE0 ,0x1F ,0xE0 ,0x7F ,0x80 ,0x0 ,0xFF ,0xE0 ,0x0 ,0x0 ,0x7F ,0xFC ,0x7F ,0xF8 ,0x1 ,0xFF ,0xF0 ,0xFF ,0x81 ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0xFE ,0x1F ,0xF ,0xE0 ,0x1F ,0xE0 ,0x3F ,0x80 ,0x0 ,0xFF ,0xE0 ,0x0 ,0x0 ,0x7F ,0xFC ,0x7F ,0xF8 ,0x1 ,0xFF ,0xF1 ,0xFF ,0x81 ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0x7F ,0x3F ,0xF ,0xE0 ,0x1F ,0xC0 ,0x3F ,0xC0 ,0x3 ,0xFF ,0xF0 ,0x0 ,0x0 ,0x7F ,0xFF ,0xFF ,0xFF ,0xF9 ,0xFF ,0xF1 ,0xFF ,0x81 ,0xFF ,0xFF ,0xE0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0x7F ,0x3F ,0xF ,0xE0 ,0x1F ,0xFF ,0xFF ,0xC0 ,0x3 ,0xFF ,0xF8 ,0x0 ,0x0 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xF1 ,0xFF ,0x81 ,0xFF ,0xFF ,0xE0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0x3F ,0x7F ,0xF ,0xE0 ,0x3F ,0xFF ,0xFF ,0xE0 ,0x3 ,0xFB ,0xFC ,0x0 ,0x0 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xE1 ,0xFF ,0x80 ,0xFF ,0xFF ,0xE0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0x3F ,0x7F ,0xF ,0xE0 ,0x3F ,0xFF ,0xFF ,0xE0 ,0x7 ,0xF1 ,0xFC ,0x0 ,0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xE1 ,0xFF ,0x0 ,0xFF ,0xFF ,0xE0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0x1F ,0x7E ,0xF ,0xE0 ,0x7F ,0xFF ,0xFF ,0xE0 ,0xF ,0xF0 ,0xFE ,0x0 ,0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xE1 ,0xFF ,0x0 ,0xFF ,0xFF ,0xC0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0x1F ,0xFE ,0xF ,0xE0 ,0x7F ,0xFF ,0xFF ,0xE0 ,0x1F ,0xF0 ,0xFF ,0x0 ,0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x81 ,0xFF ,0x0 ,0xFF ,0xFF ,0xC0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0x1F ,0xFC ,0xF ,0xE0 ,0xFF ,0x80 ,0xF ,0xF0 ,0x1F ,0xE0 ,0xFF ,0x80 ,0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xF3 ,0xFF ,0x0 ,0xFF ,0xFF ,0xC0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0x1F ,0xFC ,0xF ,0xE0 ,0xFF ,0x0 ,0xF ,0xF0 ,0x1F ,0xC0 ,0xFF ,0x80 ,0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFE ,0x0 ,0xFF ,0xFF ,0xC0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0xF ,0xFC ,0xF ,0xE0 ,0xFE ,0x0 ,0x7 ,0xF8 ,0x7F ,0x80 ,0x7F ,0x80 ,0x1 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0xF ,0xFC ,0xF ,0xE0 ,0xFE ,0x0 ,0x3 ,0xF8 ,0x7F ,0x80 ,0x3F ,0xC0 ,0x1 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0x7 ,0xF8 ,0xF ,0xE1 ,0xFC ,0x0 ,0x3 ,0xFC ,0xFF ,0x0 ,0x1F ,0xF0 ,0x1 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0x7 ,0xF8 ,0xF ,0xE1 ,0xFC ,0x0 ,0x3 ,0xFC ,0xFE ,0x0 ,0x1F ,0xF0 ,0x3 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0x3 ,0xF8 ,0xF ,0xE1 ,0xFC ,0x0 ,0x1 ,0xFC ,0xFE ,0x0 ,0xF ,0xF0 ,0x3 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7 ,0xFF ,0xFC ,0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7 ,0xFF ,0x0 ,0x0 ,0x3 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xF ,0xF0 ,0x0 ,0x0 ,0x0 ,0x7F ,0xFF ,0xFF ,0xFF ,0x87 ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xFF ,0xFF ,0xFC ,0x0 ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7F ,0xFF ,0x80 ,0x0 ,0x1F ,0xFE ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1F ,0xFE ,0x0 ,0x0 ,0x3 ,0xFE ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7 ,0xF8 ,0x0 ,0x0 ,0x0 ,0x7E ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xE0 ,0x0 ,0x0 ,0x0 ,0x3C ,0x0 ,0x0 ,0x0 ,


	};

	send_data(addr & 0xFF);
	send_data(addr >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i <1680; i++  ){
		send_data(desenho[i]);
	}
	send_command(Auto_reset);
	status(2);

	escrita_texto( 0x16A, "Analisador de eletrolitos", sizeof("Analisador de eletrolitos"));

	escrita_texto( 0x1A9, "WWW.MEDMAXNET.COM.BR", sizeof("WWW.MEDMAXNET.COM.BR"));

}

void escrita_texto( unsigned int posicao, char *texto, unsigned char tamanho ){


	send_data(posicao & 0xFF);
	send_data(posicao >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	// Apaga os textos na tela de texto
	for( int i = 0; i < tamanho - 1; i++ ){
		send_data(*(texto++) - 0x20);
	}

	send_command(Auto_reset);
	status(2);

}

void clear_display_text( void ){

	send_data(0x00);
	send_data(0x00);
	send_command(Set_address_pointer);

	send_command(Display_mode_text);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i < 480; i++ ){
		send_data(0x00);
	}

	send_command(Auto_reset);
	status(2);

}

unsigned char calibA( unsigned char wash ){

	// Declaraçõe de variáveis
	unsigned char sample = 0, estado = 0, texto = 0, segundos = 30, erroDiferencaTensoes = 0;
	unsigned int  temporizador = 1000, contError = 0, contReadAD = 0;
	unsigned long k = 0, na = 0, cl = 0, ph = 0, ca = 0;
	unsigned int medidaAnterior_K = 0, medidaAnterior_Cl = 0, medidaAnterior_Na = 0, medidaAnterior_Ca = 0, medidaAnterior_pH = 0;
	unsigned int medidaCalAnterior_K = 0, medidaCalAnterior_Cl = 0, medidaCalAnterior_Na = 0, medidaCalAnterior_Ca = 0, medidaCalAnterior_pH = 0;
	unsigned int medidasCalibSalva[6] = {1,1,1,1,1,1};
	unsigned char contAddrMemoria = 80, contadorCalib = 1, hora, minuto;
	adc16_channel_config_t adc16ChannelConfigStruct;
	adc16ChannelConfigStruct.enableInterruptOnConversionCompleted = false;
	adc16ChannelConfigStruct.enableDifferentialConversion = false;

	for( unsigned int i = ADDR_CALIBRACAO + 0x768; i >= ADDR_CALIBRACAO; i = i - DADOS_CALIBRACAO ){	// Faz a verificação de memória apagada

		if( *(volatile unsigned int *)(i) != 0xFFFFFFFF ){	// Se a memória foi escrita
			// Armazena no vetor os valores de calibração já feitos
			medidaCalAnterior_K = *(volatile unsigned short *)(i);
			medidaCalAnterior_Na = *(volatile unsigned short *)(i + DADO_MEMORIA);
			medidaCalAnterior_Cl = *(volatile unsigned short *)(i + DADO_MEMORIA * 2);
			medidaCalAnterior_Ca = *(volatile unsigned short *)(i + DADO_MEMORIA * 3);
			medidaCalAnterior_pH = *(volatile unsigned short *)(i + DADO_MEMORIA * 4);
			break;
		}
		contAddrMemoria--; // Caso não tenha encontrado memória, decrementa contador de endereço

	}

	writeLine(13);	// Escreve o desenho da linha de separação na tela

	if( !wash ){	// Se wash (lavando) igual a 0
		escrita_texto( 9, "Calibrador A", sizeof("Calibrador A"));	// Escreve Calibrador A na posição 9
		escrita_texto( 394, "Aspirando Calibrador A", sizeof("Aspirando Calibrador A"));	// Escreve "Aspirando Calibrador A" na posição 394
	}
	else
		escrita_texto( 400, "Lavando...", sizeof("Lavando..."));	// Escreve "Lavando..." na posição 400

	while( 1 ){		// Enquanto

		switch( estado ){

		case 0:	// Estado 0, movimento dos motores

			//Keep_Configuration();

			// Move motor MUX para posição 2
			move_mux(POSITION2, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 250ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, TIMER1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 838ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP2, TIMER2);
			vTaskDelay(TIMERCOM);

			// Move motor MUX para a posição 3
			move_mux(POSITION3, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 52ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, PULSE_TM);
			vTaskDelay(TIMERCOM);

			// Move motor MUX para posição 2
			move_mux(POSITION2, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 52ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, PULSE_TM);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 838ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP2, TIMER2);
			vTaskDelay(TIMERCOM);

			// Move motor MUX para a posição 3
			move_mux(POSITION3, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 52ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, PULSE_TM);
			vTaskDelay(TIMERCOM);

			// Move motor MUX para a posição 2
			move_mux(POSITION2, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 52ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, PULSE_TM);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 838ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP2, TIMER2);
			vTaskDelay(TIMERCOM);

			// Move motor MUX para a posição 3
			move_mux(POSITION3, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 52ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, PULSE_TM);
			vTaskDelay(TIMERCOM);

			// Move motor MUX para a posição 2
			move_mux(POSITION2, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 52ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, PULSE_TM);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 838ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP2, TIMER2);
			vTaskDelay(TIMERCOM);

			// Move motor MUX para a posição 3
			move_mux(POSITION3, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 52ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, PULSE_TM);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 250ms movimento rápido
			sample = move_tripa(WAYHOUR, SPEEDTRP3, TIMER1);

			// Movimenta anti horário em 250ms movimento rápido
			sample = move_tripa(WAYAHOUR, SPEEDTRP3, TIMER1);

			// Movimenta anti horário em 250ms movimento rápido
			sample = move_tripa(WAYHOUR, SPEEDTRP3, TIMER1);

			// Movimenta anti horário em 250ms movimento rápido
			sample = move_tripa(WAYAHOUR, SPEEDTRP3, TIMER1);

			// Movimenta anti horário em 250ms movimento rápido
			sample = move_tripa(WAYHOUR, SPEEDTRP3, TIMER1);

			// Movimenta anti horário em 250ms movimento rápido
			sample = move_tripa(WAYAHOUR, SPEEDTRP3, TIMER1);

			// Movimenta anti horário em 250ms movimento rápido
			sample = move_tripa(WAYHOUR, SPEEDTRP3, TIMER1);

			// Movimenta anti horário em 250ms movimento rápido
			sample = move_tripa(WAYAHOUR, SPEEDTRP3, TIMER1);

			// Movimenta anti horário em 250ms movimento rápido
			sample = move_tripa(WAYHOUR, SPEEDTRP3, TIMER1);

			// Movimenta anti horário em 2500ms movimento rápido
			sample = move_tripa(WAYAHOUR, SPEEDTRP3, TIMER3);
			vTaskDelay(TIMERCOM);

			// Move motor MUX para posição 2
			move_mux(POSITION2, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 838ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP2, 1500);
			vTaskDelay(TIMERCOM);

			// Move motor MUX para posição 1
			move_mux(POSITION1, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 15 segundos
			sample = move_tripa(WAYAHOUR, SPEEDTRP4, END_TM2);

			if( sample == 0 && contError < 2 )	// Se não detectou líquido e a contagem de error menor que 2
				contError++; // Incrementa contagem de erro

			else if( contError == 2 ){	// Senão se contagem de erro igual a 2

				// Escreve "Falta Calibrador A. Aspirar novamente?" na posição 210
				escrita_texto(210, "Falta Calibrador A. Aspirar novamente?", sizeof("Falta Calibrador A. Aspirar novamente?"));
				escrita_texto(450, "YES=Asp NO=Sair 1=Help", sizeof("YES=Asp NO=Sair 1=Help"));	// Escreve "YES=Asp NO=Sair 1=Help" na posição 450
				estado = 1;	// Estado recebe 1, não detectou líquido
				contError = 0;	// Contagem de erro recebe 0

			}
			else{	// Senão, para a detecção de líquido

				estado = 2;	// Estado recebe 2, mede a tensão dos eletrodos
				contError = 0;	// Contagem de erro recebe 0
				if( wash )
					return 0;
				else{
					writeLine(13);
					escrita_texto( 401, "Testando", sizeof("Testando") );
					vTaskDelay(10000);	// Delay de 10 segundos
					segundos = 30;
					escrita_texto(28, numtolcd(segundos,NUM), 3);	// Escreve os segundos

					//GPIO_PortClear(NXPNCI_VEN_GPIO, 1U << NXPNCI_VEN_PIN);
				}
			}
			break;

		case 1:

			if( verifyKeyBoard() == yes ){	// Se teclado igual a Yes
				estado = 0;	// Estado recebe 0, inicialização e movimento dos motores
				clear_display_text();
				writeLine(13);	// Escreve o desenho da linha de separação na tela

				if( !wash ){	// Se wash (lavando) igual a 0
					escrita_texto( 9, "Calibrador A", sizeof("Calibrador A"));	// Escreve Calibrador A na posição 9
					escrita_texto( 394, "Aspirando Calibrador A", sizeof("Aspirando Calibrador A"));	// Escreve "Aspirando Calibrador A" na posição 394
				}
				else
					escrita_texto( 400, "Lavando...", sizeof("Lavando..."));	// Escreve "Lavando..." na posição 400
			}
			else if( verifyKeyBoard() == no )	// Senão se teclado igual a No
				return ERRO_FALTA_CALIBA;	// Retorna 2

			else if( verifyKeyBoard() == um ){	// Senão se teclado igual a 1

				clearLine(10);	// Limpa a linha 10
				clearLine(11);	// Limpa a linha 11
				clearLine(12);	// Limpa a linha 12
				if( texto == 0 ) // Se se texto igual a 0
					escrita_texto(300, "Verificar a disponibilidade", sizeof("Verificar a disponibilidade"));// Escreve "Verificar a disponibilidade" na posição 330

				else if( texto == 1 )	// Senão se texto igual a 1
					// Escreve "Se a bomba estiver c/ aderencia um som diferente será ouvido"
					escrita_texto(300, "Se a bomba estiver c/ aderencia um som diferente vai ser ouvido", sizeof("Se a bomba estiver c/ aderencia um som diferente vai ser ouvido"));

				else if( texto == 2 )	// Senão se texto igual a 2
					// Escreve "O mau estado dos conectores e anéis de vedação"
					escrita_texto(300, "O mau estado dos conectores e aneis de vedacao", sizeof("O mau estado dos conectores e aneis de vedacao"));

				else if( texto == 3 )// Senão se texto igual a 3
					escrita_texto(300, "A tubulacao c/ entupimento", sizeof("A tubulacao c/ entupimento"));	// Escreve "A tubulação c/ entupimento"

				else	// Senão se texto igual a 4
					// Escreve "Favor ir para MULTIPLEXER CHECK(checar Multiplexador)"
					escrita_texto(300, "Favor ir em MULTIPLEXER CHECK (checar Multiplexador)", sizeof("Favor ir em MULTIPLEXER CHECK(checar Multiplexador)"));

				texto++;	// Texto incrementa
				if( texto == 5 )	// Se texto igual a 5
					texto = 0;	// Texto recebe 0
			}

			break;

		case 2:

			// Inicia contador de 30 segundos
			if( flag_timer ){	// Se flag timer ativar
				flag_timer = 0;	// Zera o flag timer
				temporizador--;	// Decrementa o temporizador
				if( temporizador == 0 ){	// Se temporizador chegar a 0
					temporizador = 1000;	// Reinicia o temporizador

					escrita_texto(92, "K  =   4.00 mmol/L  ", sizeof( "K  =   4.00 mmol/L  "));
					escrita_texto(112, numtolcd(voltageCalA_K, CAL), 7);
					escrita_texto(118, "mV", sizeof( "mV"));

					escrita_texto(151, "Na  = 140.00 mmol/L  ", sizeof("Na  = 140.00 mmol/L  "));
					escrita_texto(172, numtolcd(voltageCalA_Na, CAL), 7);
					escrita_texto(178, "mV", sizeof( "mV"));

					escrita_texto(211, "Cl  = 100.00 mmol/L  ", sizeof("Cl  = 100.00 mmol/L  "));
					escrita_texto(232, numtolcd(voltageCalA_Cl, CAL), 7);
					escrita_texto(238, "mV", sizeof( "mV"));

					escrita_texto(271, "Ca  =   1.25 mmol/L  ", sizeof("Ca  =   1.25 mmol/L  "));
					escrita_texto(292, numtolcd(voltageCalA_Ca, CAL), 7);
					escrita_texto(298, "mV", sizeof( "mV"));

					escrita_texto(331, "pH  =   7.40         ", sizeof("pH  =   7.40         "));
					escrita_texto(352, numtolcd(voltageCalA_pH, CAL), 7);
					escrita_texto(358, "mV", sizeof( "mV"));

					escrita_texto(28, numtolcd(segundos,NUM), 3);	// Escreve os segundos
					segundos--; // Decrementa segundos
					if( segundos == 0 ){	// Se segundos for igual a 0
						estado = 3;
					}
				}
			}

			if( segundos > 0 ){	// Se segundos maior que 0
				if( contReadAD < 1000 ){	// Se contAD menor que 50
					adc16ChannelConfigStruct.channelNumber                        = 8;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					ph += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura ph e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 9;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					ca += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura ca e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 12;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					cl += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura cl e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 13;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					na += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura na e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 14;
					ADC16_SetChannelConfig(ADC1, 1, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC1, 1)))
					{
					}
					k += ADC16_GetChannelConversionValue(ADC1, 1);	// Faz leitura k e incrementa

					contReadAD++;	// Incrementa contAD

				}
				else{	// Senão
					voltageCalA_K =	k * 8.0325 / contReadAD;	// Calcula a tensão para k. Medida atual
					voltageCalA_pH = ph * 8.0325 / contReadAD;	// Calcula a tensão para ph. Medida atual
					voltageCalA_Ca = ca * 8.0325 / contReadAD;	// Calcula a tensão para ca. Medida atual
					voltageCalA_Cl = cl * 8.0325 / contReadAD;	// Calcula a tensão para cl. Medida atual
					voltageCalA_Na = na * 8.0325 / contReadAD;	// Calcula a tensão para na. Medida atual
					k = 0;
					ph = 0;
					ca = 0;
					cl = 0;
					na = 0;

					// Faz a verificação da diferença e armazena o erro em uma flag
					if( medidaAnterior_K != 0 && medidaAnterior_Ca != 0 && medidaAnterior_Na != 0 && medidaAnterior_Cl != 0 && medidaAnterior_pH != 0 ){

						if( abs(medidaAnterior_K - voltageCalA_K) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorK);
						else
							erroDiferencaTensoes |= 1 << ErrorK;

						if( abs(medidaAnterior_Na - voltageCalA_Na) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorNa);
						else
							erroDiferencaTensoes |= 1 << ErrorNa;

						if( abs(medidaAnterior_Cl - voltageCalA_Cl) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorCl);
						else
							erroDiferencaTensoes |= 1 << ErrorCl;

						if( abs(medidaAnterior_Ca - voltageCalA_Ca) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorCa);
						else
							erroDiferencaTensoes |= 1 << ErrorCa;

						if( abs(medidaAnterior_pH - voltageCalA_pH) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorpH);

						else
							erroDiferencaTensoes |= 1 << ErrorpH;
					}

					if( erroDiferencaTensoes == 0 && segundos < 27 ){	// Se diferença for menor que 500 e segundo menor que 27

						while( flagNfcRead );
						I2C_READ_PCF8653( &hora, Hours ) ;	// Medida de hora do RTC
						I2C_READ_PCF8653( &minuto, Minutes );	// Medida de minuto do RTC
						medidasCalibSalva[0] = voltageCalA_K;	// Salva calibrador K
						medidasCalibSalva[1] = voltageCalA_Na;	// Salva calibrador Na
						medidasCalibSalva[2] = voltageCalA_Cl;	// Salva calibrador Cl
						medidasCalibSalva[3] = voltageCalA_Ca;	// Salva calibrador Ca
						medidasCalibSalva[4] = voltageCalA_pH;	// Salva calibrador pH
						medidasCalibSalva[5] = bcdtodec(hora & 0x3F) << 16 | bcdtodec(minuto & 0x7F) << 8 | contadorCalib;	// Salva horário, contador de calibração e 0 para calibrador A
						FLASH_Program(&s_flashDriver, ADDR_CALIBRACAO + contAddrMemoria * DADOS_CALIBRACAO, medidasCalibSalva, DADOS_CALIBRACAO);	// Salva dados de calibração

						contAddrMemoria++;	// Incrementa contador de memória

						if( abs(medidaCalAnterior_K - voltageCalA_K) > 500 ||
								abs(medidaCalAnterior_Na - voltageCalA_Na) > 500 ||
								abs(medidaCalAnterior_Cl - voltageCalA_Cl) > 500 ||
								abs(medidaCalAnterior_Ca - voltageCalA_Ca) > 500 ||
								abs(medidaCalAnterior_pH - voltageCalA_pH) > 500 ){
							contadorCalib++;
							if( contadorCalib > 3 )
								estado = 3;
							else{
								clearLine(3);
								clearLine(5);
								clearLine(7);
								clearLine(9);
								clearLine(11);
								escrita_texto(28, "  ", sizeof("  "));
								escrita_texto( 394, "Aspirando Calibrador A", sizeof("Aspirando Calibrador A"));	// Escreve "Aspirando Calibrador A" na posição 394
								estado = 0;
							}
						}
						else{
							estado = 3;
						}
						if( estado != 3 ){
							medidaCalAnterior_K = *(volatile unsigned short *)(ADDR_CALIBRACAO + (contAddrMemoria - 1) * DADOS_CALIBRACAO);	// Lê o valor de calibração anterior K
							medidaCalAnterior_Na = *(volatile unsigned short *)(ADDR_CALIBRACAO + (contAddrMemoria - 1) * DADOS_CALIBRACAO + DADO_MEMORIA);	// Lê o valor de calibração anterior Na
							medidaCalAnterior_Cl = *(volatile unsigned short *)(ADDR_CALIBRACAO + (contAddrMemoria - 1) * DADOS_CALIBRACAO + DADO_MEMORIA*2);	// Lê o valor de calibração anterior Cl
							medidaCalAnterior_Ca = *(volatile unsigned short *)(ADDR_CALIBRACAO + (contAddrMemoria - 1) * DADOS_CALIBRACAO + DADO_MEMORIA*3);	// Lê o valor de calibração anterior Ca
							medidaCalAnterior_pH = *(volatile unsigned short *)(ADDR_CALIBRACAO + (contAddrMemoria - 1) * DADOS_CALIBRACAO + DADO_MEMORIA*4);	// Lê o valor de calibração anterior pH
						}
					}
					else if( erroDiferencaTensoes != 0 && segundos == 0 ){	// Senão

						estado = 0;			// Estado recebe 0
						contError++;				// contErro incrementa
						if( contError == 2 ){	// Se contErro igual a 2
							estado = 3;			// Estado recebe 3 (Verificação de erros)
							contError = 0;		// Zera contador de erro
							escrita_texto(450, "YES=CALIBRAR NO=SAIR", sizeof("YES=CALIBRAR NO=SAIR"));
						}

					}
					contReadAD = 1;	// Zera contador de leitura AD

					// Medida anterior recebe Medida atual
					medidaAnterior_K = voltageCalA_K;
					medidaAnterior_Na = voltageCalA_Na;
					medidaAnterior_Ca = voltageCalA_Ca;
					medidaAnterior_Cl = voltageCalA_Cl;
					medidaAnterior_pH = voltageCalA_pH;

				}
			}
			if( estado == 3 ){

				//Keep_Configuration();

				if( (contError = verifyError(TYPEA, NOABNORMAL)) != 0 ){	// Verifica se deu erro de valor fora da faixa ou anormal
					clearLine(3);
					clearLine(5);
					clearLine(7);
					clearLine(9);
					clearLine(11);
					writeLine(13);
					escrita_texto(28, "  ", sizeof("  "));
					stateMachineError(120, contError & 0xFF, 1);	// Escreve mV fora da faixa para os respectivos eletrodos
					stateMachineError(150, contError >> 8, 2);	// Escreve anormal para os respectivos eletrodos
					stateMachineError(90, contError >> 16, 3);
					escrita_texto(450, "YES=CALIBRAR NO=SAIR", sizeof("YES=CALIBRAR NO=SAIR"));
				}
			}
			break;

		case 3:		// Estado de verificação de erro

			if( contError == 0 ){	// Se não há erro de verificação e se o teste está ok

				escrita_texto( 400, "Finalizado!", sizeof("Finalizado!") );
				vTaskDelay(4000);
				flagBuz = 1;
				return OK;	// Retorna 0

			}
			else{	// Senão
				if( verifyKeyBoard() == yes ){	// Se o botão yes foi pressionado
					estado = 0;	// Estado 0, movimento dos motores
					contError = 0;	// Zera o contador de erro
					contadorCalib = 1; // Reseta o valor do contador de calibração
					clearLine(3);	// Apaga linha 3
					clearLine(4);	// Apaga linha 4
					clearLine(5);	// Apaga linha 5
					clearLine(15);	// Apaga linha 15
					escrita_texto( 394, "Aspirando Calibrador A", sizeof("Aspirando Calibrador A"));	// Escreve "Aspirando Calibrador A" na posição 394
				}
				else if( verifyKeyBoard() == no )	// Se o botão No foi pressionado
					return ERRO; 	// Retorna o valor do erro de instabilidade
			}

			break;

		}

	}

}

unsigned char calibB( void ){

	unsigned char sample = 0, segundos = 30, estado = 0, erroDiferencaTensoes = 0, texto = 0;
	unsigned int  temporizador = 1000, contError = 0, contReadAD = 0;
	unsigned long k = 0, na = 0, cl = 0, ph = 0, ca = 0;
	long medidaAnterior_K = 0, medidaAnterior_Cl = 0, medidaAnterior_Na = 0, medidaAnterior_Ca = 0, medidaAnterior_pH = 0;
	unsigned int medidaCalAnterior_K = 0, medidaCalAnterior_Cl = 0, medidaCalAnterior_Na = 0, medidaCalAnterior_Ca = 0, medidaCalAnterior_pH = 0;
	unsigned int medidasCalibSalva[6] = {0,0,0,0,0,0};
	unsigned char contAddrMemoria = 80, contadorCalib = 1, hora, minuto;
	adc16_channel_config_t adc16ChannelConfigStruct;
	adc16ChannelConfigStruct.enableInterruptOnConversionCompleted = false;
	adc16ChannelConfigStruct.enableDifferentialConversion = false;

	writeLine(13);	// Escreve o desenho da linha de separação na tela

	escrita_texto( 9, "Calibrador B", sizeof("Calibrador B"));	// Escreve Calibrador A na posição 9
	escrita_texto( 394, "Aspirando Calibrador B", sizeof("Aspirando Calibrador B"));	// Escreve "Aspirando Calibrador A" na posição 394

	for( unsigned int i = ADDR_CALIBRACAO + 0xEE8; i >= ADDR_CALIBRACAO + 0x780; i = i - DADOS_CALIBRACAO ){	// Faz a verificação de memória apagada

		if( *(volatile unsigned int *)(i) != 0xFFFFFFFF ){	// Se a memória foi escrita
			// Armazena no vetor os valores de calibração já feitos
			medidaCalAnterior_K = *(volatile unsigned short *)(i);
			medidaCalAnterior_Na = *(volatile unsigned short *)(i + DADO_MEMORIA);
			medidaCalAnterior_Cl = *(volatile unsigned short *)(i + DADO_MEMORIA * 2);
			medidaCalAnterior_Ca = *(volatile unsigned short *)(i + DADO_MEMORIA * 3);
			medidaCalAnterior_pH = *(volatile unsigned short *)(i + DADO_MEMORIA * 4);
			break;
		}
		contAddrMemoria--; // Caso não tenha encontrado memória, decrementa contador de endereço

	}

	writeLine(13);
	escrita_texto( 0x09, "Calibrador B", sizeof("Calibrador B"));
	escrita_texto( 0x18A, "Aspirando Calibrador B", sizeof("Aspirando Calibrador B"));

	while( 1 ){		// Enquanto

		switch( estado ){

		case 0:	// Estado 0, movimento dos motores

			//Keep_Configuration();

			// Move motor MUX para posição 3
			move_mux(POSITION3, SPEEDMUX1);

			// Movimenta anti horário em 910ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, 910);
			vTaskDelay(TIMERCOM * 8); // Delay de 2 segundos

			// Move motor MUX para a posição 4
			move_mux(POSITION4, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 2,82 s
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, 2820);
			vTaskDelay(TIMERCOM / 2); // Delay 125 ms

			// Move motor MUX para a posição 3
			move_mux(POSITION3, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 870ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, 870);
			vTaskDelay(TIMERCOM + 50);

			// Movimenta anti horário em 52ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP2, 1650);
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, 3800);
			vTaskDelay(2250);

			// Move motor MUX para a posição 3
			move_mux(POSITION4, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 52ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP4, 15000);
			vTaskDelay(TIMERCOM);

			if( sample == 0 && contError < 2 )	// Se não detectou líquido e a contagem de error menor que 2
				contError++; // Incrementa contagem de erro

			else if( contError == 2 ){	// Senão se contagem de erro igual a 2

				// Escreve "Falta Calibrador A. Aspirar novamente?" na posição 210
				escrita_texto(210, "Falta Calibrador B. Aspirar novamente?", sizeof("Falta Calibrador B. Aspirar novamente?"));
				escrita_texto(450, "YES=Asp NO=Sair 1=Help", sizeof("YES=Asp NO=Sair 1=Help"));	// Escreve "YES=Asp NO=Sair 1=Help" na posição 450
				estado = 1;	// Estado recebe 1, não detectou líquido
				contError = 0;	// Contagem de erro recebe 0

			}
			else{	// Senão, para a detecção de líquido

				estado = 2;	// Estado recebe 2, mede a tensão dos eletrodos
				contError = 0;	// Contagem de erro recebe 0
				writeLine(13);
				escrita_texto( 401, "Testando", sizeof("Testando") );
				vTaskDelay(10000);	// Delay de 10 segundos
				segundos = 30;
				escrita_texto(28, numtolcd(segundos,NUM), 3);	// Escreve os segundos
				//GPIO_PortClear(NXPNCI_VEN_GPIO, 1U << NXPNCI_VEN_PIN);

			}
			break;

		case 1:

			if( verifyKeyBoard() == yes ){	// Se teclado igual a Yes
				estado = 0;	// Estado recebe 0, inicialização e movimento dos motores
				clear_display_text();
				writeLine(13);	// Escreve o desenho da linha de separação na tela

				escrita_texto( 9, "Calibrador B", sizeof("Calibrador B"));	// Escreve Calibrador A na posição 9
				escrita_texto( 394, "Aspirando Calibrador B", sizeof("Aspirando Calibrador B"));	// Escreve "Aspirando Calibrador A" na posição 394

			}
			else if( verifyKeyBoard() == no )	// Senão se teclado igual a No
				return ERRO_FALTA_CALIBB;	// Retorna 2

			else if( verifyKeyBoard() == um ){	// Senão se teclado igual a 1

				clearLine(10);	// Limpa a linha 10
				clearLine(11);	// Limpa a linha 11
				clearLine(12);	// Limpa a linha 12
				if( texto == 0 ) // Se se texto igual a 0
					escrita_texto(300, "Verificar a disponibilidade", sizeof("Verificar a disponibilidade"));// Escreve "Verificar a disponibilidade" na posição 330

				else if( texto == 1 )	// Senão se texto igual a 1
					// Escreve "Se a bomba estiver c/ aderencia um som diferente será ouvido"
					escrita_texto(300, "Se a bomba estiver c/ aderencia um som diferente vai ser ouvido", sizeof("Se a bomba estiver c/ aderencia um som diferente vai ser ouvido"));

				else if( texto == 2 )	// Senão se texto igual a 2
					// Escreve "O mau estado dos conectores e anéis de vedação"
					escrita_texto(300, "O mau estado dos conectores e aneis de vedacao", sizeof("O mau estado dos conectores e aneis de vedacao"));

				else if( texto == 3 )// Senão se texto igual a 3
					escrita_texto(300, "A tubulacao c/ entupimento", sizeof("A tubulacao c/ entupimento"));	// Escreve "A tubulação c/ entupimento"

				else	// Senão se texto igual a 4
					// Escreve "Favor ir para MULTIPLEXER CHECK(checar Multiplexador)"
					escrita_texto(300, "Favor ir em MULTIPLEXER CHECK (checar Multiplexador)", sizeof("Favor ir em MULTIPLEXER CHECK(checar Multiplexador)"));

				texto++;	// Texto incrementa
				if( texto == 5 )	// Se texto igual a 5
					texto = 0;	// Texto recebe 0
			}

			break;

		case 2:

			// Inicia contador de 30 segundos
			if( flag_timer ){	// Se flag timer ativar
				flag_timer = 0;	// Zera o flag timer
				temporizador--;	// Decrementa o temporizador
				if( temporizador == 0 ){	// Se temporizador chegar a 0
					temporizador = 1000;	// Reinicia o temporizador
					segundos--;
					escrita_texto(28, numtolcd(segundos,NUM), 3);	// Escreve os segundos

					escrita_texto(92, "K  =   8.00 mmol/L  ", sizeof( "K  =   8.00 mmol/L  "));
					escrita_texto(112, numtolcd(voltageCalB_K, CAL), 7);
					escrita_texto(118, "mV", sizeof( "mV"));

					escrita_texto(151, "Na  = 110.00 mmol/L  ", sizeof("Na  = 110.00 mmol/L  "));
					escrita_texto(172, numtolcd(voltageCalB_Na, CAL), 7);
					escrita_texto(178, "mV", sizeof( "mV"));

					escrita_texto(211, "Cl  =  70.00 mmol/L  ", sizeof("Cl  =  70.00 mmol/L  "));
					escrita_texto(232, numtolcd(voltageCalB_Cl, CAL), 7);
					escrita_texto(238, "mV", sizeof( "mV"));

					escrita_texto(271, "Ca  =   2.50 mmol/L  ", sizeof("Ca  =   2.50 mmol/L  "));
					escrita_texto(292, numtolcd(voltageCalB_Ca, CAL), 7);
					escrita_texto(298, "mV", sizeof( "mV"));

					escrita_texto(331, "pH  =   7.00         ", sizeof("pH  =   7.00        "));
					escrita_texto(352, numtolcd(voltageCalB_pH, CAL), 7);
					escrita_texto(358, "mV", sizeof( "mV"));

					if( segundos == 0 ){	// Se segundos for igual a 0
						estado = 3;
					}
				}
			}

			if( segundos > 0 ){	// Se segundos maior que 0
				if( contReadAD < 1750 ){	// Se contAD menor que 50
					adc16ChannelConfigStruct.channelNumber                        = 8;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					ph += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura ph e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 9;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					ca += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura ca e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 12;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					cl += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura cl e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 13;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					na += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura na e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 14;
					ADC16_SetChannelConfig(ADC1, 1, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC1, 1)))
					{
					}
					k += ADC16_GetChannelConversionValue(ADC1, 1);	// Faz leitura k e incrementa

					contReadAD++;	// Incrementa contAD

				}
				else{	// Senão
					voltageCalB_K =	k * 8.0325 / contReadAD;	// Calcula a tensão para k. Medida atual
					voltageCalB_pH = ph * 8.0325 / contReadAD;	// Calcula a tensão para ph. Medida atual
					voltageCalB_Ca = ca * 8.0325 / contReadAD;	// Calcula a tensão para ca. Medida atual
					voltageCalB_Cl = cl * 8.0325 / contReadAD;	// Calcula a tensão para cl. Medida atual
					voltageCalB_Na = na * 8.0325 / contReadAD;	// Calcula a tensão para na. Medida atual
					k = 0;
					ph = 0;
					ca = 0;
					cl = 0;
					na = 0;

					// Faz a verificação da diferença e armazena o erro em uma flag
					if( medidaAnterior_K != 0 && medidaAnterior_Ca != 0 && medidaAnterior_Na != 0 && medidaAnterior_Cl != 0 && medidaAnterior_pH != 0 ){

						if( abs(medidaAnterior_K - voltageCalB_K) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorK);
						else
							erroDiferencaTensoes |= 1 << ErrorK;

						if( abs(medidaAnterior_Na - voltageCalB_Na) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorNa);
						else
							erroDiferencaTensoes |= 1 << ErrorNa;

						if( abs(medidaAnterior_Cl - voltageCalB_Cl) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorCl);
						else
							erroDiferencaTensoes |= 1 << ErrorCl;

						if( abs(medidaAnterior_Ca - voltageCalB_Ca) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorCa);
						else
							erroDiferencaTensoes |= 1 << ErrorCa;

						if( abs(medidaAnterior_pH - voltageCalB_pH) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorpH);
						else
							erroDiferencaTensoes |= 1 << ErrorpH;
					}

					if( erroDiferencaTensoes == 0 && segundos < 27 ){	// Se diferença for menor que 500 e segundo menor que 27

						while( flagNfcRead );
						I2C_READ_PCF8653( &hora, Hours ) ;	// Medida de hora do RTC
						I2C_READ_PCF8653( &minuto, Minutes );	// Medida de minuto do RTC
						medidasCalibSalva[0] = voltageCalB_K;	// Salva calibrador K
						medidasCalibSalva[1] = voltageCalB_Na;	// Salva calibrador Na
						medidasCalibSalva[2] = voltageCalB_Cl;	// Salva calibrador Cl
						medidasCalibSalva[3] = voltageCalB_Ca;	// Salva calibrador Ca
						medidasCalibSalva[4] = voltageCalB_pH;	// Salva calibrador pH
						medidasCalibSalva[5] = 0x01 << 24 | bcdtodec(hora & 0x3F) << 16 | bcdtodec(minuto & 0x7F) << 8 | contadorCalib;	// Salva horário, contador de calibração e 0 para calibrador A
						FLASH_Program(&s_flashDriver, ADDR_CALIBRACAO + 0x780 + contAddrMemoria * DADOS_CALIBRACAO, medidasCalibSalva, DADOS_CALIBRACAO);	// Salva dados de calibração

						contAddrMemoria++;	// Incrementa contador de memória

						if( abs(medidaCalAnterior_K - voltageCalB_K) > 500 ||
								abs(medidaCalAnterior_Na - voltageCalB_Na) > 500 ||
								abs(medidaCalAnterior_Cl - voltageCalB_Cl) > 500 ||
								abs(medidaCalAnterior_Ca - voltageCalB_Ca) > 500 ||
								abs(medidaCalAnterior_pH - voltageCalB_pH) > 500 ){
							contadorCalib++;
							if( contadorCalib > 3 )
								estado = 3;
							else{
								clearLine(3);
								clearLine(5);
								clearLine(7);
								clearLine(9);
								clearLine(11);
								escrita_texto(28, "  ", sizeof("  "));
								escrita_texto( 394, "Aspirando Calibrador B", sizeof("Aspirando Calibrador B"));	// Escreve "Aspirando Calibrador A" na posição 394
								estado = 0;
							}
						}
						else{
							estado = 3;
						}
						if( estado != 3 ){
							medidaCalAnterior_K = *(volatile unsigned short *)(ADDR_CALIBRACAO + 0x780 + (contAddrMemoria - 1) * DADOS_CALIBRACAO);	// Lê o valor de calibração anterior K
							medidaCalAnterior_Na = *(volatile unsigned short *)(ADDR_CALIBRACAO + 0x780 + (contAddrMemoria - 1) * DADOS_CALIBRACAO + DADO_MEMORIA);	// Lê o valor de calibração anterior Na
							medidaCalAnterior_Cl = *(volatile unsigned short *)(ADDR_CALIBRACAO + 0x780 + (contAddrMemoria - 1) * DADOS_CALIBRACAO + DADO_MEMORIA*2);	// Lê o valor de calibração anterior Cl
							medidaCalAnterior_Ca = *(volatile unsigned short *)(ADDR_CALIBRACAO + 0x780 + (contAddrMemoria - 1) * DADOS_CALIBRACAO + DADO_MEMORIA*3);	// Lê o valor de calibração anterior Ca
							medidaCalAnterior_pH = *(volatile unsigned short *)(ADDR_CALIBRACAO + 0x780 + (contAddrMemoria - 1) * DADOS_CALIBRACAO + DADO_MEMORIA*4);	// Lê o valor de calibração anterior pH
						}
					}
					else if( erroDiferencaTensoes != 0 && segundos == 0 ){	// Senão

						estado = 0;			// Estado recebe 0
						contError++;				// contErro incrementa
						if( contError == 2 ){	// Se contErro igual a 2
							estado = 3;			// Estado recebe 3 (Verificação de erros)
							escrita_texto(450, "YES=CALIBRAR NO=SAIR", sizeof("YES=CALIBRAR NO=SAIR"));
						}

					}
					contReadAD = 1;	// Zera contador de leitura AD

					// Medida anterior recebe Medida atual
					medidaAnterior_K = voltageCalB_K;
					medidaAnterior_Na = voltageCalB_Na;
					medidaAnterior_Ca = voltageCalB_Ca;
					medidaAnterior_Cl = voltageCalB_Cl;
					medidaAnterior_pH = voltageCalB_pH;


				}
			}
			if( estado == 3 ){

				//Keep_Configuration();

				if( (contError = verifyError(TYPEB, ABNORMAL)) != 0 ){	// Verifica se deu erro de valor fora da faixa ou anormal
					clearLine(3);
					clearLine(5);
					clearLine(7);
					clearLine(9);
					clearLine(11);
					writeLine(13);
					escrita_texto(28, "  ", sizeof("  "));
					stateMachineError(120, contError & 0xFF, 1);	// Escreve mV fora da faixa para os respectivos eletrodos
					stateMachineError(150, contError >> 8, 2);	// Escreve anormal para os respectivos eletrodos
					stateMachineError(90, contError >> 16, 3);	// Escreve variandp e qual dos eletrodos que não está instável
					escrita_texto(450, "YES=CALIBRAR NO=SAIR", sizeof("YES=CALIBRAR NO=SAIR"));

				}
			}
			break;

		case 3:		// Estado de verificação de erro

			if( contError == 0 ){	// Se não há erro de verificação e se o teste está ok

				escrita_texto( 400, "Finalizado!", sizeof("Finalizado!") );
				vTaskDelay(4000);
				flagBuz = 1;
				return OK;	// Retorna 0

			}
			else{	// Senão
				if( verifyKeyBoard() == yes ){	// Se o botão yes foi pressionado
					estado = 0;	// Estado 0, movimento dos motores
					contError = 0;	// Zera o contador de erro
					contadorCalib = 1; // Reseta o valor do contador de calibração
					clearLine(3);	// Apaga linha 3
					clearLine(4);	// Apaga linha 4
					clearLine(5);	// Apaga linha 5
					clearLine(15);	// Apaga linha 15
					escrita_texto( 394, "Aspirando Calibrador B", sizeof("Aspirando Calibrador B"));	// Escreve "Aspirando Calibrador A" na posição 394
				}
				else if( verifyKeyBoard() == no )	// Se o botão No foi pressionado
					return ERRO; 	// Retorna o valor do erro de instabilidade
			}

			break;

		}

	}
}

unsigned char TesteAmostras( unsigned char tipoTeste ){

	unsigned char sample, contReadAd = 0, estado = 0, segundos = 0, respMotor = 0,  erroDiferencaTensoes = 0;
	unsigned int dadosMemoria[8];
	unsigned int contReadAD = 0, timeout = 0, temporizador;
	unsigned int medidaAnterior_K = 0, medidaAnterior_Cl = 0, medidaAnterior_Na = 0, medidaAnterior_Ca = 0, medidaAnterior_pH = 0;
	static unsigned long k = 0, na = 0, cl = 0, ph = 0, ca = 0;
	unsigned int contAddrMemoria = 0, examesFeitos = 1, flagExame = 0;
	unsigned long long codigoDeBarras = 1, auxiliarCodigoDebarras;
	adc16_channel_config_t adc16ChannelConfigStruct;
	adc16ChannelConfigStruct.enableInterruptOnConversionCompleted = false;
	adc16ChannelConfigStruct.enableDifferentialConversion = false;

	for( unsigned int i = ADDR_EXAME; i < 0xF7120; i = i + DADOS_EXAMES )	// Faz a verificação de memória apagada
	{
		if( *(volatile unsigned int *)(i) == 0xFFFFFFFF )	// Se a memória foi escrita
		{
			break;
		}
		else
		{
			examesFeitos++;	// Incrementa quantidade de exames feitos
			contAddrMemoria++; // Caso não tenha encontrado memória, decrementa contador de endereço
			codigoDeBarras = (((*(volatile unsigned long long *)(i + 24) & 0xFFFF ) << 32)  |
					(*(volatile unsigned int *)(i + 28))) + 1;
		}

	}

	float slopeEletrodos[5], interceptEletrodos[5];
	// Verificação se há dados salvos de Slope para o eletrodo K
	if( *(volatile unsigned int *)(ADDR_CONFIGURACAO + ADDR_SLOPE_K) != 0xFFFFFFFF )
		slopeEletrodos[0] = *(volatile float *)(ADDR_CONFIGURACAO + ADDR_SLOPE_K);
	else
		slopeEletrodos[0] = 1;

	// Verificação se há dados salvos de Slope para o eletrodo Na
	if( *(volatile unsigned int *)(ADDR_CONFIGURACAO + ADDR_SLOPE_Na) != 0xFFFFFFFF )
		slopeEletrodos[1] = *(volatile float *)(ADDR_CONFIGURACAO + ADDR_SLOPE_Na);
	else
		slopeEletrodos[1] = 1;

	// Verificação se há dados salvos de Slope para o eletrodo Cl
	if( *(volatile unsigned int *)(ADDR_CONFIGURACAO + ADDR_SLOPE_Cl) != 0xFFFFFFFF )
		slopeEletrodos[2] = *(volatile float *)(ADDR_CONFIGURACAO + ADDR_SLOPE_Cl);
	else
		slopeEletrodos[2] = 1;

	// Verificação se há dados salvos de Slope para o eletrodo Ca
	if( *(volatile unsigned int *)(ADDR_CONFIGURACAO + ADDR_SLOPE_Ca) != 0xFFFFFFFF )
		slopeEletrodos[3] = *(volatile float *)(ADDR_CONFIGURACAO + ADDR_SLOPE_Ca);
	else
		slopeEletrodos[3] = 1;

	// Verificação se há dados salvos de Slope para o eletrodo pH
	if( *(volatile unsigned int *)(ADDR_CONFIGURACAO + ADDR_SLOPE_pH) != 0xFFFFFFFF )
		slopeEletrodos[4] = *(volatile float *)(ADDR_CONFIGURACAO + ADDR_SLOPE_pH);
	else
		slopeEletrodos[4] = 1;

	// Verificação se há dados salvos de intercept para o eletrodo K
	if( *(volatile unsigned int *)(ADDR_CONFIGURACAO + ADDR_INTERCEPT_K) != 0xFFFFFFFF )
		interceptEletrodos[0] = *(volatile float *)(ADDR_CONFIGURACAO + ADDR_INTERCEPT_K);
	else
		interceptEletrodos[0] = 0;

	// Verificação se há dados salvos de intercept para o eletrodo Na
	if( *(volatile unsigned int *)(ADDR_CONFIGURACAO + ADDR_INTERCEPT_Na) != 0xFFFFFFFF )
		interceptEletrodos[1] = *(volatile float *)(ADDR_CONFIGURACAO + ADDR_INTERCEPT_Na);
	else
		interceptEletrodos[1] = 0;

	// Verificação se há dados salvos de intercept para o eletrodo Cl
	if( *(volatile unsigned int *)(ADDR_CONFIGURACAO + ADDR_INTERCEPT_Cl) != 0xFFFFFFFF )
		interceptEletrodos[2] = *(volatile float *)(ADDR_CONFIGURACAO + ADDR_INTERCEPT_Cl);
	else
		interceptEletrodos[2] = 0;

	// Verificação se há dados salvos de intercept para o eletrodo Ca
	if( *(volatile unsigned int *)(ADDR_CONFIGURACAO + ADDR_INTERCEPT_Ca) != 0xFFFFFFFF )
		interceptEletrodos[3] = *(volatile float *)(ADDR_CONFIGURACAO + ADDR_INTERCEPT_Ca);
	else
		interceptEletrodos[3] = 0;

	// Verificação se há dados salvos de intercept para o eletrodo pH
	if( *(volatile unsigned int *)(ADDR_CONFIGURACAO + ADDR_INTERCEPT_pH) != 0xFFFFFFFF )
		interceptEletrodos[4] = *(volatile float *)(ADDR_CONFIGURACAO + ADDR_INTERCEPT_pH);
	else
		interceptEletrodos[4] = 0;




	while( 1 )
	{

		switch(estado)
		{
		case 0:	//Início movimento dos motores

			//Keep_Configuration();

			writeLine(0);
			writeLine(13);

			if( tipoTeste == SORO )	// Se tipoTeste igual a SORO
			{
				escrita_texto( 0x08, "TESTE DE SORO", sizeof("TESTE DE SORO"));	// Escreve "Teste de Soro"
			}
			else if( tipoTeste == SANGUE )	// Senão se tipoTeste igual a SANGUE
			{
				escrita_texto( 0x06, "TESTE DE SANGUE", sizeof("TESTE DE SANGUE"));	// Escreve "Teste de Sangue"
			}
			else if( tipoTeste == URINA )	// Senão se tipoTeste igual a URINA
			{
				escrita_texto( 0x07, "TESTE DE URINA", sizeof("TESTE DE URINA"));	// Escreve "Teste de Urina"
				escrita_texto( 331, "Favor diluir a urina no calibrador A na propor",
						sizeof( "Favor diluir a urina no calibrador A na propor" ));	// Escreve "Favor diluir a urina no calibrador A na propor"
				EscreveCedilhaAOTil();
				escrita_texto(381, " 1:9", sizeof(" 1:9"));	// Escreve "1:9"
			}

			// Movimenta anti horário em 910ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, 950);
			vTaskDelay(TIMERCOM + 50); // Delay de 2 segundos

			// Move motor MUX para posição 3
			move_mux(POSITION3, SPEEDMUX1);

			// Movimenta anti horário em 2,82 s
			sample = move_tripa(WAYAHOUR, SPEEDTRP2, 1000);

			// Movimenta anti horário em 870ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP3, 1000);
			vTaskDelay(TIMERCOM + 50);

			// Move motor MUX para a posição 1
			move_mux(POSITION1, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			escrita_texto( 30, ConverteNumParaLcd(4, 0, examesFeitos), 5);	// Escreve a quantidade de exames na posição 30
			escrita_texto( 34, ":", sizeof(":"));	// Escreve : na posição 34
			escrita_texto( 35, ConverteNumParaLcd( 2, 0, ( codigoDeBarras / 10000000000 )), ContaCaracteres() + 1 );	// Escreve o dia salvo com 2 dígitos
			escrita_texto( 37, ConverteNumParaLcd( 5, 0, ( codigoDeBarras % 10000000000 / 100000 ) ), ContaCaracteres() + 1 );	// Escreve o dia salvo com 2 dígitos
			escrita_texto( 42, ConverteNumParaLcd( 5, 0, codigoDeBarras % 100000 ), ContaCaracteres() + 1 );	// Escreve o dia salvo com 2 dígitos
			escrita_texto( 271, "Levante a Sonda para Aspirar", sizeof("Levante a Sonda para Aspirar"));
			escrita_texto( 450, "YES=Asp", sizeof("YES=Asp"));
			escrita_texto( 459, "NO=Sair", sizeof("NO=Sair"));
			escrita_texto( 473, "<=Serie", sizeof("<=Serie"));

			estado = 1;
			break;

		case 1:	// Estado 1. Verificação da agulha


			if( verifyKeyBoard() == left )	// Senão se tecla igual a left
			{
				auxiliarCodigoDebarras = EscreveCodigoDeBarras();
				if( auxiliarCodigoDebarras == 0 )	// Se a resposta for igual a 0, indica erro
				{
					// Escreve o valor anterior
					escrita_texto( 35, ConverteNumParaLcd( 2, 0, ( codigoDeBarras / 10000000000 )), ContaCaracteres() + 1 );	// Escreve o dia salvo com 2 dígitos
					escrita_texto( 37, ConverteNumParaLcd( 5, 0, ( codigoDeBarras % 10000000000 / 100000 ) ), ContaCaracteres() + 1 );	// Escreve o dia salvo com 2 dígitos
					escrita_texto( 42, ConverteNumParaLcd( 5, 0, codigoDeBarras % 100000 ), ContaCaracteres() + 1 );	// Escreve o dia salvo com 2 dígitos
				}
				else
				{
					codigoDeBarras = auxiliarCodigoDebarras;	// Recebe o valor atual de código de barras
				}
			}
			else if( agulhaFechada ){	// Se sonda fechada
				if( flag_timer ){	// Se flag timer igual a 1
					flag_timer = 0;	// Flag timer recebe 0
					timeout++;	// Incrementa timeout de 1
					if( timeout >= 60000 || verifyKeyBoard() == no  ){	// Se timeout é maior ou igual a 60000 (1 minuto) ou teclado igual a No

						move_mux(POSITION1, SPEEDMUX1);	// Move mux para a posição 1
						clear_display_text();	// Limpa a tela
						if( flagExame )	// Se detectou líquido e fez um exame
						{
							calibA(1);	// Chama a função lavando
						}
						return OK;

					}
				}
			}
			else if( agulhaAberta ){		// Se Sonda está aberta
				estado = 2;		// Estado recebe 1
				timeout = 0;	// Timeout recebe 0
			}

			break;

		case 2:	// Estado 2. Leitura da sonda e verificação de timeout
			if( flag_timer ){	// Se flag timer igual a 1
				flag_timer = 0;	// Flag timer recebe 0
				timeout++;	// Incrementa timeout de 1
				if( timeout >= 60000  ){	// Se timeout é maior ou igual a 60000 (1 minuto) ou teclado igual a No

					move_mux(POSITION1, SPEEDMUX1);	// Move mux para a posição 1
					clear_display_text();	// Limpa a tela
					if( flagExame )	// Se detectou líquido e fez um exame
					{
						calibA(1);	// Chama a função lavando
					}
					return OK;

				}
			}
			else if( verifyKeyBoard() == yes )	// Se teclado igual a Yes
			{
				escrita_texto(401, "Aspirando", sizeof("Aspirando"));		// Escreve “Aspirando“ na linha 390
				move_tripa(WAYAHOUR,SPEEDTRP1,1200);	// Aciona tripa por 2,4 segundos na velocidade 1
				clearLine(7);	// Apaga a linha 7
				clearLine(9);	// Apaga a linha 9
				escrita_texto(215, "Favor abaixar a Sonda", sizeof("Favor abaixar a Sonda"));	// Escreve “Favor abaixar a Sonda” na posição 210
				while( agulhaAberta );	// Enquanto a sonda está aberta
				clearLine(7);
				respMotor = move_tripa(WAYAHOUR,SPEEDTRP4,15000);	// Aciona tripa por 15 segundos
				if( respMotor == 1 && agulhaFechada ){	// Se detectou líquido
					estado = 3;
					temporizador = 1000;	// Temporizador recebe 1000 para contagem de 1 segundo
					segundos = 30;	// Segundo recebe 59
					writeLine(13);
					escrita_texto( 401, "Testando", sizeof("Testando") );
					vTaskDelay(10000);	// Delay de 10 segundos
					escrita_texto(28, numtolcd(segundos,NUM), 3);	// Escreve segundo
					flagExame = 1;
					//GPIO_PortClear(NXPNCI_VEN_GPIO, 1U << NXPNCI_VEN_PIN);
				}
				else{

					estado = 5;	// Estado de erro de detecção de líqudo
					if( agulhaAberta ){	// Se a agulha está aberta
						escrita_texto(395, "Favor baixar a agulha", sizeof("Favor baixar a agulha"));	// Escreve "Favor baixar a agulha"
						while( agulhaAberta );	// Aguarda até a agulha ser abaixada
					}

				}
			}
			else if( verifyKeyBoard() == no ){	// Se teclado igual a No
				move_mux(POSITION1, SPEEDMUX1);	// Move mux para a posição 1
				clear_display_text();	// Limpa a tela
				return OK;
			}
			else if( verifyKeyBoard() == left )	// Senão se tecla igual a left
			{
				auxiliarCodigoDebarras = EscreveCodigoDeBarras();
				if( auxiliarCodigoDebarras == 0 )	// Se a resposta for igual a 0, indica erro
				{
					// Escreve o valor anterior
					escrita_texto( 35, ConverteNumParaLcd( 2, 0, ( codigoDeBarras / 10000000000 )), ContaCaracteres() + 1 );	// Escreve o dia salvo com 2 dígitos
					escrita_texto( 37, ConverteNumParaLcd( 5, 0, ( codigoDeBarras % 10000000000 / 100000 ) ), ContaCaracteres() + 1 );	// Escreve o dia salvo com 2 dígitos
					escrita_texto( 42, ConverteNumParaLcd( 5, 0, codigoDeBarras % 100000 ), ContaCaracteres() + 1 );	// Escreve o dia salvo com 2 dígitos
				}
				else
				{
					codigoDeBarras = auxiliarCodigoDebarras;	// Recebe o valor atual de código de barras
				}
			}
			break;

		case 3:	// Se detectou líquido começa a contagem de tempo

			// Inicia contador de 30 segundos
			if( flag_timer ){	// Se flag timer ativar
				flag_timer = 0;	// Zera o flag timer
				temporizador--;	// Decrementa o temporizador
				if( temporizador == 0 ){	// Se temporizador chegar a 0
					temporizador = 1000;	// Reinicia o temporizador

					escrita_texto(28, numtolcd(segundos,NUM), 3);	// Escreve os segundos

					escrita_texto(91, "K    ", sizeof("K   "));
					escrita_texto(97, ConverteNumParaLcd(ContaDigitos(Ck), 2, Ck), ContaCaracteres() + 1);
					escrita_texto(104, "mmol/L", sizeof("mmol/L"));
					escrita_texto(112, ConverteNumParaLcd( ContaDigitos(k * 8.0325 / contReadAD), 2, k * 8.0325 / contReadAD), ContaCaracteres() + 1 );
					escrita_texto(118, "mV", sizeof( "mV"));

					escrita_texto(151, "Na    ", sizeof("K   "));
					escrita_texto(157, ConverteNumParaLcd(ContaDigitos(Cna), 2, Cna), ContaCaracteres() + 1);
					escrita_texto(164, "mmol/L", sizeof("mmol/L"));
					escrita_texto(172, ConverteNumParaLcd( ContaDigitos(na * 8.0325 / contReadAD), 2, na * 8.0325 / contReadAD), ContaCaracteres() + 1 );
					escrita_texto(178, "mV", sizeof( "mV"));

					escrita_texto(211, "Cl    ", sizeof("Cl   "));
					escrita_texto(217, ConverteNumParaLcd(ContaDigitos(Ccl), 2, Ccl), ContaCaracteres() + 1);
					escrita_texto(224, "mmol/L", sizeof("mmol/L"));
					escrita_texto(232, ConverteNumParaLcd( ContaDigitos(cl * 8.0325 / contReadAD), 2, cl * 8.0325 / contReadAD), ContaCaracteres() + 1 );
					escrita_texto(238, "mV", sizeof( "mV"));

					escrita_texto(271, "Ca    ", sizeof("Ca    "));
					escrita_texto(277, ConverteNumParaLcd(ContaDigitos(Cca), 2, Cca), ContaCaracteres() + 1);
					escrita_texto(284, "mmol/L", sizeof("mmol/L"));
					escrita_texto(292, ConverteNumParaLcd( ContaDigitos(ca * 8.0325 / contReadAD), 2, ca * 8.0325 / contReadAD), ContaCaracteres() + 1 );
					escrita_texto(298, "mV", sizeof( "mV"));

					escrita_texto(331, "pH    ", sizeof("pH    "));
					escrita_texto(337, ConverteNumParaLcd(ContaDigitos(CpH), 2, CpH), ContaCaracteres() + 1);
					escrita_texto(344, "      ", sizeof("      "));
					escrita_texto(352, ConverteNumParaLcd( ContaDigitos(ph * 8.0325 / contReadAD), 2, ph * 8.0325 / contReadAD), ContaCaracteres() + 1 );
					escrita_texto(358, "mV", sizeof( "mV"));

					segundos--; // Decrementa segundos
					if( segundos == 0 ){	// Se segundos for igual a 0
						estado = 4;
					}
				}
			}

			if( segundos > 0 ){	// Se segundos maior que 0
				if( contReadAD < 250 ){	// Se contAD menor que 50
					adc16ChannelConfigStruct.channelNumber                        = 8;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					ph += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura ph e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 9;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					ca += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura ca e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 12;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					cl += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura cl e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 13;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					na += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura na e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 14;
					ADC16_SetChannelConfig(ADC1, 1, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC1, 1)))
					{
					}
					k += ADC16_GetChannelConversionValue(ADC1, 1);	// Faz leitura k e incrementa

					contReadAD++;	// Incrementa contAD

				}
				else{
					Ck = Ck_standard * pow( 10, (k * 8.0325 / contReadAD) / ( ( voltageCalB_K - voltageCalA_K ) * 3.32 ) ) * 100 * slopeEletrodos[0] + interceptEletrodos[0] * 100;
					CpH = CpH_standard * pow( 10, (ph * 8.0325 / contReadAD) / ( ( voltageCalB_pH - voltageCalA_pH ) * 47.19 ) )* 100 * slopeEletrodos[4] + interceptEletrodos[4] * 100;
					Cca = Cca_standard * pow( 10, (ca * 8.0325 / contReadAD) / ( ( voltageCalB_Ca - voltageCalA_Ca ) * 3.31 ) ) * 100 * slopeEletrodos[3] + interceptEletrodos[3] * 100;
					Ccl = Ccl_standard * pow( 10, (cl * 8.0325 / contReadAD) / ( (int)( voltageCalA_Cl - voltageCalB_Cl ) * 5.105) ) * 100 * slopeEletrodos[2] + interceptEletrodos[2] * 100;
					Cna = Cna_standard * pow( 10, (na * 8.0325 / contReadAD) / ( ( voltageCalA_Na - voltageCalB_Na ) * 9.633) ) * 100 * slopeEletrodos[1] + interceptEletrodos[1] * 100;
					float tCa = Cca * ( 200 + ( CpH - 740 ) ) / 100;	// Cálculo para cálcio total
					float nCa = Cca * ( 100 +  0.5 * ( CpH - 740 ) ) / 100;	// Cálculo para o cálcio normalizado
					// Faz a verificação da diferença e armazena o erro em uma flag
					if( medidaAnterior_K != 0 && medidaAnterior_Ca != 0 && medidaAnterior_Na != 0 && medidaAnterior_Cl != 0 && medidaAnterior_pH != 0 ){

						if( abs(medidaAnterior_K - Ck) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorK);
						else
							erroDiferencaTensoes |= 1 << ErrorK;

						if( abs(medidaAnterior_Na - Cna) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorNa);
						else
							erroDiferencaTensoes |= 1 << ErrorNa;

						if( abs(medidaAnterior_Cl - Ccl) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorCl);
						else
							erroDiferencaTensoes |= 1 << ErrorCl;

						if( abs(medidaAnterior_Ca - Cca) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorCa);
						else
							erroDiferencaTensoes |= 1 << ErrorCa;

						if( abs(medidaAnterior_pH - CpH) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorpH);
						else
							erroDiferencaTensoes |= 1 << ErrorpH;
					}
					medidaAnterior_K = Ck;	// Recebe e leitura Ck anterior
					medidaAnterior_Na = Cna;	// Recebe e leitura Cna anterior
					medidaAnterior_Ca = Cca;	// Recebe e leitura Cca anterior
					medidaAnterior_Cl = Ccl;	// Recebe e leitura Ccl anterior
					medidaAnterior_pH = CpH;	// Recebe e leitura CpH anterior
					k = 0;
					ph = 0;
					ca = 0;
					cl = 0;
					na = 0;
					contReadAD = 1;
					if( erroDiferencaTensoes == 0 && segundos < 27 ){
						//Keep_Configuration();
						estado = 4;
						dadosMemoria[0] = Ck * 100;	// dadosMemoria[0] recebe Ck
						dadosMemoria[1] = Cna * 100;	// dadosMemoria[1] recebe Cna
						dadosMemoria[2] = Ccl * 100;	// dadosMemoria[2] recebe Ccl
						dadosMemoria[3] = Cca * 100;	// dadosMemoria[3] recebe Cca
						dadosMemoria[4] = CpH * 100;	// dadosMemoria[4] recebe CpH
						unsigned char mes, dia, hora, minuto, ano;	// Declaração das variáveis de tempo
						while( flagNfcRead );
						I2C_READ_PCF8653(&ano, Years);	// Lê o ano do RTC
						I2C_READ_PCF8653(&mes, Century_months);	// Lê a mês do RTC
						I2C_READ_PCF8653(&dia, Days);	// Lê a dia do RTC
						I2C_READ_PCF8653(&hora, Hours);	// Lê a hora do RTC
						I2C_READ_PCF8653(&minuto, Minutes);	// Lê a minuto do RTC
						dadosMemoria[5] = mes << 24 | dia << 16 | hora << 8 | minuto;	// dadosMemoria[5] recebe mês movido 24 bits para a esquerda mais dia movido 16 bits para esquerda mais hora movido 8 bits para esquerda mais minuto
						dadosMemoria[6] = codigoDeBarras >> 32 | (ano << 24);	// dadosMemoria[6] recebe codigoDeBarras movido 32 bits para a direita (4 bytes)
						dadosMemoria[7] = codigoDeBarras & 0xFFFFFFFF;	// dadosMemoria[7] recebe codigoDeBarras e 0xFFFFFFFF
						FLASH_Program(&s_flashDriver, ADDR_EXAME + contAddrMemoria * DADOS_EXAMES, dadosMemoria, DADOS_EXAMES);	// Salva dados de calibração

						PrinterInicializa(LETRA_GRANDE);
						PrinterTexto("RESULTADO", sizeof("RESULTADO"), PRINT_TEXTO);
						PrinterInicializa(LETRA_PEQUENA);
						PrinterTexto("ID:", sizeof("ID:"), NAO_PRINTA);
						PrinterCodigoDeBarras(codigoDeBarras);
						PrinterInicializa(LETRA_PEQUENA);
						PrinterTexto(ConverteNumParaLcd(4, 0, examesFeitos), ContaCaracteres(), PRINT_TEXTO);
						PrinterTexto(" K =", sizeof("K ="), NAO_PRINTA);
						PrinterTexto(ConverteNumParaLcd(ContaDigitos(Ck), 2, Ck), ContaCaracteres(), NAO_PRINTA);
						PrinterTexto("mmol/L", sizeof("mmol/L"), PRINT_TEXTO);
						PrinterInicializa(LETRA_PEQUENA);
						PrinterTexto(" Na=", sizeof("Na="), NAO_PRINTA);
						PrinterTexto(ConverteNumParaLcd(ContaDigitos(Cna), 2, Cna), ContaCaracteres(), NAO_PRINTA);
						PrinterTexto("mmol/L", sizeof("mmol/L"), PRINT_TEXTO);
						PrinterInicializa(LETRA_PEQUENA);
						PrinterTexto("iCa=", sizeof("iCa="), NAO_PRINTA);
						PrinterTexto(ConverteNumParaLcd(ContaDigitos(Cca), 2, Cca), ContaCaracteres(), NAO_PRINTA);
						PrinterTexto("mmol/L", sizeof("mmol/L"), PRINT_TEXTO);
						PrinterTexto("tCa=", sizeof("tCa="), NAO_PRINTA);
						PrinterTexto(ConverteNumParaLcd(ContaDigitos(tCa), 2, tCa), ContaCaracteres(), NAO_PRINTA);
						PrinterTexto("mmol/L", sizeof("mmol/L"), PRINT_TEXTO);
						PrinterTexto("nCa=", sizeof("nCa="), NAO_PRINTA);
						PrinterTexto(ConverteNumParaLcd(ContaDigitos(nCa), 2, nCa), ContaCaracteres(), NAO_PRINTA);
						PrinterTexto("mmol/L", sizeof("mmol/L"), PRINT_TEXTO);
						PrinterInicializa(LETRA_PEQUENA);
						PrinterTexto(" Cl=", sizeof(" Cl="), NAO_PRINTA);
						PrinterTexto(ConverteNumParaLcd(ContaDigitos(Ccl), 2, Ccl), ContaCaracteres(), NAO_PRINTA);
						PrinterTexto("mmol/L", sizeof("mmol/L"), PRINT_TEXTO);
						PrinterInicializa(LETRA_PEQUENA);
						PrinterTexto(" pH=", sizeof(" pH="), NAO_PRINTA);
						PrinterTexto(ConverteNumParaLcd(ContaDigitos(CpH), 2, CpH), ContaCaracteres(), PRINT_TEXTO);
						EnviaComando(0x0A);
						EnviaComando(0x0A);
						EnviaComando(0x0A);
						EnviaComando(0x0A);

						examesFeitos++;	// Incrementa a quantidade de exames
						codigoDeBarras++; // Incrementa o código de barras
						contAddrMemoria++;	// Incrementa o contador de variável
						exame_feito = 1;	// Flag indicador de exame feito
						if(codigoDeBarras == pow(10,14))	// Se código de barras igual a 10^14, passou dos 13 dígitos
						{
							codigoDeBarras = 1;	// Código de barras recebe 1
						}
						if( examesFeitos == 2570 )	// Se exames feitos igual a 2570, passou da quantidade de exames salvos
						{
							examesFeitos = 1;	// Exames feitos recebe 1
						}

					}
					else if(erroDiferencaTensoes == 0 && segundos == 0){


						escrita_texto(28, "  ", sizeof("  "));
						escrita_texto(210, "Eletrodos instaveis, aspirar novamente?", sizeof("Eletrodos instaveis, aspirar novamente?"));	// Escreve "Aspirando Calibrador A" na posição 394
						estado = 7;

					}

				}

				break;

		case 4:	// Estado 4. Temporizador terminou ou teclado No foi pressionado

			if(examesFeitos % 10 == 0) // Após 10 exames faz uma calibração de 1 ponto
			{
				respMotor = calibA(0); // Calibração de 1 ponto calibA(0)
			}
			else
			{
				respMotor = calibA(1);	// Lavando (calib(1)).Faz verificação de líquido. Passa 3 vezes
			}

			if( respMotor == OK || respMotor == ERRO ){	// Se identificou líquido na lavagem
				writeLine(0);
				writeLine(13);

				if( tipoTeste == SORO )	// Se tipoTeste igual a SORO
				{
					escrita_texto( 0x08, "TESTE DE SORO", sizeof("TESTE DE SORO"));	// Escreve "Teste de Soro"
				}
				else if( tipoTeste == SANGUE )	// Senão se tipoTeste igual a SANGUE
				{
					escrita_texto( 0x06, "TESTE DE SANGUE", sizeof("TESTE DE SANGUE"));	// Escreve "Teste de Sangue"
				}
				else if( tipoTeste == URINA )	// Senão se tipoTeste igual a URINA
				{
					escrita_texto( 0x07, "TESTE DE URINA", sizeof("TESTE DE URINA"));	// Escreve "Teste de Urina"
					escrita_texto( 331, "Favor diluir a urina no calibrador A na propor",
							sizeof( "Favor diluir a urina no calibrador A na propor" ));	// Escreve "Favor diluir a urina no calibrador A na propor"
					EscreveCedilhaAOTil();
					escrita_texto(381, " 1:9", sizeof(" 1:9"));	// Escreve "1:9"
				}

				clearLine(3);
				clearLine(5);
				clearLine(7);
				clearLine(9);
				clearLine(11);
				move_mux(POSITION1, SPEEDMUX1);	// Move mux para a posição 1
				estado = 0;
			}

			break;

		case 5:	// Estado 5. Falta de detecção de líquido

			respMotor = calibA(1);	// Lavando (calib(1)).Faz verificação de líquido. Passa 3 vezes
			if( respMotor == OK || respMotor == ERRO ){	// Se não identificou líquido na lavagem
				move_mux(POSITION1, SPEEDMUX1);	// Move mux para a posição 1
				writeLine(13);	// Desenha na linha 13
				clearLine(8);
				escrita_texto(210, "Sem amostra. Aspirar novamente?", sizeof("Sem amostra. Aspirar novamente?"));	// Escreve “Sem amostra. Aspirar novamente?”
				estado = 7;	// Estado de verificação de botão para retornar ao início
			}


			break;

		case 7:	// Estado 7. Verificação de botão para retornar ao estado inicial

			verifyKeyBoard();
			if( verifyKeyBoard() == yes ){
				clearLine(7);
				clearLine(8);
				escrita_texto(210, "Levante a sonda para aspirar", sizeof("Levante a sonda para aspirar"));		// Escreve “Levante a sonda para aspirar” na linha 210
				estado = 1;	// Verificação de sonda aberta
			}
			else if( verifyKeyBoard() == no ){

				clear_display_text();	// Limpa a tela
				return ERRO;

			}
			break;

		case 8:	// Caso 8 - Escreve código de barras

			EscreveCodigoDeBarras();

			break;
			/*readQueueKeyboard = verifyKeyBoard();

		if( readQueueKeyboard == yes ){

			// Movimenta anti horário em 870ms
			clearLine(9);
			sample = move_tripa(WAYAHOUR, SPEEDTRP2, 1250);
			while( agulhaAberta );
			sample = move_tripa(WAYAHOUR, SPEEDTRP4, 15000);

			if( sample == 0 )
				return 1;
			else{
				while( contReadAd < 20 ){
					while( contAD < 1000 ){

						adc16ChannelConfigStruct.channelNumber                        = 8;
						ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
						while (0U == (kADC16_ChannelConversionDoneFlag &
								ADC16_GetChannelStatusFlags(ADC0, 0)))
						{
						}
						ph += ADC16_GetChannelConversionValue(ADC0, 0);

						adc16ChannelConfigStruct.channelNumber                        = 9;
						ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
						while (0U == (kADC16_ChannelConversionDoneFlag &
								ADC16_GetChannelStatusFlags(ADC0, 0)))
						{
						}
						ca += ADC16_GetChannelConversionValue(ADC0, 0);

						adc16ChannelConfigStruct.channelNumber                        = 12;
						ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
						while (0U == (kADC16_ChannelConversionDoneFlag &
								ADC16_GetChannelStatusFlags(ADC0, 0)))
						{
						}
						cl += ADC16_GetChannelConversionValue(ADC0, 0);

						adc16ChannelConfigStruct.channelNumber                        = 13;
						ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
						while (0U == (kADC16_ChannelConversionDoneFlag &
								ADC16_GetChannelStatusFlags(ADC0, 0)))
						{
						}
						na += ADC16_GetChannelConversionValue(ADC0, 0);

						adc16ChannelConfigStruct.channelNumber                        = 14;
						ADC16_SetChannelConfig(ADC1, 1, &adc16ChannelConfigStruct);
						while (0U == (kADC16_ChannelConversionDoneFlag &
								ADC16_GetChannelStatusFlags(ADC1, 1)))
						{
						}
						k += ADC16_GetChannelConversionValue(ADC1, 1);

						contAD++;
					}
					Ck = Ck_standard * pow( 10, (k * 8.0325 / contAD) / ( ( voltageCalB_K - voltageCalA_K ) * 3.32 ) );
					CpH = CpH_standard * pow( 10, (ph * 8.0325 / contAD) / ( ( voltageCalB_pH - voltageCalA_pH ) * 47.19 ) );
					Cca = Cca_standard * pow( 10, (ca * 8.0325 / contAD) / ( ( voltageCalB_Ca - voltageCalA_Ca ) * 3.31 ) ) * 100;
					Ccl = Ccl_standard * pow( 10, (cl * 8.0325 / contAD) / ( ( voltageCalA_Cl - voltageCalB_Cl ) * 5.105) ) * 100;
					Cna = Cna_standard * pow( 10, (na * 8.0325 / contAD) / ( ( voltageCalB_Na - voltageCalA_Na ) * 9.633) );


					escrita_texto(211, "Cl    ", sizeof("Cl   "));
					escrita_texto(217, numtolcd(Ccl, CAL), 7);
					escrita_texto(224, "mmol/L", sizeof("mmol/L"));
					escrita_texto(232, numtolcd(cl * 8.0325 / contAD, CAL), 7);
					escrita_texto(238, "mV", sizeof( "mV"));

					escrita_texto(271, "Ca    ", sizeof("Ca    "));
					escrita_texto(277, numtolcd(Cca, CAL), 7);
					escrita_texto(284, "mmol/L", sizeof("mmol/L"));
					escrita_texto(292, numtolcd(ca * 8.0325 / contAD, CAL), 7);
					escrita_texto(298, "mV", sizeof( "mV"));

					k = 0;
					na = 0;
					ca = 0;
					ph = 0;
					cl = 0;
					contReadAd++;
					contAD = 0;

				}
				contReadAd = 0;
				readQueueKeyboard = 0;
				vTaskDelay( 5000 );
				clearLine(7);
				clearLine(9);
			}
		}*/
			}
		}
	}
	return 0;
}

char *numtolcd( unsigned int num, unsigned char typeCalOrNum ){

	const int dm = 10000, m = 1000;
	const char c = 100, d = 10;

	if( typeCalOrNum == CAL ){
		if( num > dm ){

			data[0] = num / dm + 0x30;
			data[1] = ( num % dm ) / m + 0x30;
			data[2] = ( ( num % dm ) % m ) / c + 0x30;
			data[3] = 0x0E + 0x20;	// Vírgula no código LCD
			data[4] = ( ( ( num % dm ) % m ) % c ) / d + 0x30;
			data[5] = ( ( ( num % dm ) % m ) % c ) % d + 0x30;

		}
		else if( num > m ){

			data[0] = 0x20; // Espaço no código LCD
			data[1] = num / m + 0x30;
			data[2] = ( ( num % m ) ) / c + 0x30;
			data[3] = 0x0E + 0x20; // Vírgula no código LCD
			data[4] = ( ( ( num % dm ) % m ) % c ) / d + 0x30;
			data[5] = ( ( ( num % dm ) % m ) % c ) % d + 0x30;

		}
	}
	else if( typeCalOrNum == NUM ){

		if( num < c ){
			if( num < d )
				data[0] = 0x30; // Espaço no código LCD

			else
				data[0] = num / 10 + 0x30;; // Espaço no código LCD

			data[1] = num % 10 + 0x30;
			data[2] = 0;
			data[3] = 0;
			data[4] = 0;
			data[5] = 0;
		}
		else{

			data[0] = num / dm + 0x30;
			data[1] = ( num % dm ) / m + 0x30;
			data[2] = ( ( num % dm ) % m ) / c + 0x30;
			data[3] = ( ( ( num % dm ) % m ) % c ) / d + 0x30;
			data[4] = 0x0E + 0x20;	// Vírgula no código LCD
			data[5] = ( ( ( num % dm ) % m ) % c ) % d + 0x30;

		}
	}
	return (data);

}

unsigned char writeLine( unsigned int line ){

	if( line > 15 )
		return 0;
	line = line * 30;
	send_data(line & 0xFF);
	send_data(line >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	// Apaga os textos na tela de texto
	for( char i = 0; i < 30; i++ ){
		send_data(0x82);
	}

	send_command(Auto_reset);
	status(2);

	return 1;

}

unsigned char clearLine( unsigned int line ){

	if( line > 15 )
		return 0;
	line = line * 30;
	send_data(line & 0xFF);
	send_data(line >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	// Apaga os textos na tela de texto
	for( char i = 0; i < 30; i++ ){
		send_data(0x00);
	}

	send_command(Auto_reset);
	status(2);

	return 1;

}

void WriteMenuName( unsigned char menu, unsigned char tipoMenu ){

	static unsigned char menu_anterior, menuAnteriorConfig, menuAnteriorServico;
	clearLine(12);
	if( tipoMenu == PRINCIPAL ){	// Se tipoMenu igual a PRINCIPAL

		switch( menu ){	// Máquina de estado para definir escrita

		case 0:	// Caso 0 escreve "1 PONTO"
			escrita_texto(371, "1 PONTO", sizeof("1 PONTO"));
			break;
		case 1:	// Caso 1 escreve "2 PONTOS"
			escrita_texto(371, "2 PONTOS", sizeof("2 PONTOS"));
			break;
		case 2:	// Caso 2 escreve "MANUTENÇÃO"
			escrita_texto(370, "MANUTEN", sizeof("MANUTEN"));
			EscreveCedilhaAOTil();
			break;
		case 3:	// Caso 3 escreve "TESTE DE SORO"
			escrita_texto(368, "TESTE DE SORO", sizeof("TESTE DE SORO"));
			break;
		case 4:	// Caso 4 escreve "TESTE DE SANGUE TOTAL"
			escrita_texto(364, "TESTE DE SANGUE TOTAL", sizeof("TESTE DE SANGUE TOTAL"));
			break;
		case 5:	// Caso 5 escreve "TESTE DE URINA"
			escrita_texto(368, "TESTE DE URINA", sizeof("TESTE DE URINA"));
			break;
		case 6:	// Caso 6 escreve "TESTE DE C.Q."
			escrita_texto(368, "TESTE DE C.Q.", sizeof("TESTE DE C.Q."));
			break;
		case 7:	// Caso 7 escreve "CONFIGURAÇÃO"
			escrita_texto(368, "CONFIGURA", sizeof("CONFIGURA"));
			EscreveCedilhaAOTil();
			break;
		case 8:	// Caso 8 escreve "SERVIÇO"
			escrita_texto(372, "SERVI", sizeof("SERVI"));
			send_data(0x60);	// Comando para escrever Ç
			send_command(0xC0);	 // Escreve com incremente de um passo no endereço do display
			status(1);
			send_data(0x2F);	// Comando para escrever O
			send_command(0xC0);	// Escreve com incremente de um passo no endereço do display
			status(1);
			break;
		case 9: // Caso 9 escreve "SERVIÇO"
			escrita_texto(372, "SERVI", sizeof("SERVI"));
			send_data(0x60);	// Comando para escrever Ç
			send_command(0xC0);	 // Escreve com incremente de um passo no endereço do display
			status(1);
			send_data(0x2F);	// Comando para escrever O
			send_command(0xC0);	// Escreve com incremente de um passo no endereço do display
			status(1);
			break;
		}
		desenha_fundo_menu( menu_anterior % 4, 0 );
		if( ( menu_anterior == 8 || menu_anterior == 4 ) && ( menu >= 0 && menu < 4 ) )
			desenho_menu1();
		else if( ( menu_anterior == 3 || menu_anterior == 8 )  && ( menu >= 4 && menu < 8 ))
			desenho_menu2();
		else if( ( menu_anterior == 7 || menu_anterior == 0 ) && ( menu == 8 )  )
			desenho_menu3();
		desenha_fundo_menu( menu % 4, 1 );
		send_command(Mode_set_exor);
		status(1);
		menu_anterior = menu;
	}
	else if( tipoMenu == CONFIGURACAO ){	// Se tipoMenu igual a CONFIGURACAO

		switch( menu ){	// Máquina de estado para definir escrita

		case 0:	// Caso 0 escreve "DATA E HORA"
			escrita_texto(369, "DATA E HORA", sizeof("DATA E HORA"));
			break;
		case 1:	// Caso 1 escreve "FAIXA DE VALOR DE REFERÊNCIA"
			escrita_texto(361, "FAIXA DE VALOR DE REFERENCIA", sizeof("FAIXA DE VALOR DE REFERENCIA"));
			break;
		case 2:	// Caso 2 escreve "INTERVALO DE MANUTENÇÃO"
			escrita_texto(363, "INTERVALO DE MANUTEN", sizeof("INTERVALO DE MANUTEN"));
			EscreveCedilhaAOTil();
			break;
		case 3:	// Caso 3 escreve "CANAL DE TESTES"
			escrita_texto(367, "CANAL DE TESTES", sizeof("CANAL DE TESTES"));
			break;
		case 4:	// Caso 4 escreve "VOLUME DE AMOSTRAS"
			escrita_texto(366, "VOLUME DE AMOSTRAS", sizeof("VOLUME DE AMOSTRAS"));
			break;
		case 5:	// Caso 5 escreve "FATOR DE CORRELAÇÃO"
			escrita_texto(366, "FATOR DE CORRELA", sizeof("FATOR DE CORRELA"));
			EscreveCedilhaAOTil();
			break;
		case 6:	// Caso 6 escreve "CONFIGURAR IMPRESSORA"
			escrita_texto(365, "CONFIGURAR IMPRESSORA", sizeof("CONFIGURAR IMPRESSORA"));
			break;
		case 7:	// Caso 7 escreve "CONTRASTE DO DISPLAY"
			escrita_texto(365, "CONTRASTE DO DISPLAY", sizeof("CONTRASTE DO DISPLAY"));
			break;
		case 8:	// Caso 8 escreve "MODO DE CALIBRAÇÃO"
			escrita_texto(367, "MODO DE CALIBRA", sizeof("MODO DE CALIBRA"));
			EscreveCedilhaAOTil();
			break;
		case 9:	// Caso 8 escreve "SELEÇÃO DE LINGUA"
			escrita_texto(367, "SELE", sizeof("SELE"));
			EscreveCedilhaAOTil();
			escrita_texto(374,  " DE LINGUA", sizeof(" DE LINGUA"));
			break;

		}
		desenha_fundo_menu( menuAnteriorConfig % 4, 0 );
		if( ( menuAnteriorConfig == 9 || menuAnteriorConfig == 4 ) && ( menu >= 0 && menu < 4 ) )
			desenho_configuracao1();
		else if( ( menuAnteriorConfig == 3 || menuAnteriorConfig == 8 )  && ( menu >= 4 && menu < 8 ))
			desenho_configuracao2();
		else if( ( menuAnteriorConfig == 7 || menuAnteriorConfig == 0 ) && ( menu == 9 || menu == 8 )  )
			desenho_configuracao3();
		desenha_fundo_menu( menu % 4, 1 );
		send_command(Mode_set_exor);
		status(1);
		menuAnteriorConfig = menu;
	}
	else if( tipoMenu == SERVICO ){	// Se tipoMenu igual a SERVICO

		switch( menu ){	// Máquina de estado para definir escrita

		case 0:	// Caso 0 escreve "RECUPERACAO DADOS"
			escrita_texto(369, "RECUPERA", sizeof("RECUPERA"));
			EscreveCedilhaAOTil();
			escrita_texto(381, " DADOS", sizeof(" DADOS"));
			break;
		case 1:	// Caso 1 escreve "DADOS DE CALIBRAÇÃO"
			escrita_texto(361, "DADOS DE CALIBRA", sizeof("DADOS DE CALIBRA"));
			EscreveCedilhaAOTil();
			break;
		case 2:	// Caso 2 escreve "TRANSF. DADOS"
			escrita_texto(363, "TRANSF. DADOS", sizeof("TRANSF. DADOS"));
			EscreveCedilhaAOTil();
			break;
		case 3:	// Caso 3 escreve "PARADA DO EQUIPAMENTO"
			escrita_texto(367, "PARADA DO EQUIPAMENTO", sizeof("PARADA DO EQUIPAMENTO"));
			break;
		case 4:	// Caso 4 escreve "VERIFICAÇÃO DO MULTIPLEXADOR"
			escrita_texto(366, "VERIFICA", sizeof("VERIFICA"));
			EscreveCedilhaAOTil();
			escrita_texto(382, " DO MULTIPLEXADOR", sizeof(" DO MULTIPLEXADOR"));
			break;
		case 5:	// Caso 5 escreve "SUBSTITUIR REAGENTES"
			escrita_texto(366, "SUBSTITUIR REAGENTES", sizeof("SUBSTITUIR REAGENTES"));
			break;
		case 6:	// Caso 6 escreve "UNIDADE"
			escrita_texto(365, "UNIDADE", sizeof("UNIDADE"));
			break;
		}
		desenha_fundo_menu( menuAnteriorServico % 4, 0 );
		if( ( menuAnteriorServico == 9 || menuAnteriorServico == 4 ) && ( menu >= 0 && menu < 4 ) )
			desenho_configuracao1();
		else if( ( menuAnteriorServico == 3 || menuAnteriorServico == 8 )  && ( menu >= 4 && menu < 8 ))
			desenho_configuracao2();
		else if( ( menuAnteriorServico == 7 || menuAnteriorServico == 0 ) && ( menu == 9 || menu == 8 )  )
			desenho_configuracao3();
		desenha_fundo_menu( menu % 4, 1 );
		send_command(Mode_set_exor);
		status(1);
		menuAnteriorServico = menu;
	}
}

void calibValues( void ){

	Ck_standard = 4 / ( pow( 10, ( voltageCalA_K  / (float)( ( voltageCalB_K - voltageCalA_K ) * 3.32 ) ) ) );
	Cna_standard = 140 / ( pow( 10, voltageCalA_Na / (float)( ( voltageCalA_Na - voltageCalB_Na ) * 9.633) ) );
	Ccl_standard = 110 / ( pow( 10, voltageCalA_Cl / ( (int)( voltageCalA_Cl - voltageCalB_Cl ) * 5.105 ) ) );
	Cca_standard = 1.25 / ( pow( 10, voltageCalA_Ca / (float)( ( voltageCalB_Ca - voltageCalA_Ca ) * 3.31 ) ) );
	CpH_standard = 7.4 / ( pow( 10, voltageCalA_pH / (float)( ( voltageCalB_pH - voltageCalA_pH ) * 47.19 ) ) );

}

unsigned int verifyError( unsigned char typeAorB, unsigned char abnormal ){

	unsigned char contError = 0, contErrorAbnormal = 0;
	unsigned int medidaCalAnterior_K = 0, medidaCalAnterior_Cl = 0, medidaCalAnterior_Na = 0, medidaCalAnterior_Ca = 0, medidaCalAnterior_pH = 0;
	unsigned char contAddrMemoria = 80, erroDiferencaTensoes = 0;

	if( typeAorB == 1 ){
		if( voltageCalA_K < 4500 || voltageCalA_K > 14000 )
			contError |= 1 << ErrorK;
		else
			contError &= ~(1 << ErrorK);

		if( voltageCalA_Na < 4500 || voltageCalA_Na > 12000 )
			contError |= 1 << ErrorNa;
		else
			contError &= ~(1 << ErrorNa);

		if( voltageCalA_Cl < 5000 || voltageCalA_Cl > 12000 )
			contError |= 1 << ErrorCl;
		else
			contError &= ~(1 << ErrorCl);

		if( voltageCalA_Ca < 3500 || voltageCalA_Ca > 10000 )
			contError |= 1 << ErrorCa;
		else
			contError &= ~(1 << ErrorCa);

		if( voltageCalA_pH < 7000 || voltageCalA_pH > 17000 )
			contError |= 1 << ErrorpH;
		else
			contError &= ~(1 << ErrorpH);

		for( unsigned int i = ADDR_CALIBRACAO + 0x768; i >= ADDR_CALIBRACAO; i = i - DADOS_CALIBRACAO ){	// Faz a verificação de memória apagada

			if( *(volatile unsigned int *)(i) != 0xFFFFFFFF ){	// Se a memória foi escrita
				// Armazena no vetor os valores de calibração já feitos
				break;
			}
			contAddrMemoria--;

		}
		medidaCalAnterior_K = *(volatile unsigned short *)(ADDR_CALIBRACAO + (contAddrMemoria - 1) * DADOS_CALIBRACAO);	// Lê o valor de calibração anterior K
		medidaCalAnterior_Na = *(volatile unsigned short *)(ADDR_CALIBRACAO + (contAddrMemoria - 1) * DADOS_CALIBRACAO + DADO_MEMORIA);	// Lê o valor de calibração anterior Na
		medidaCalAnterior_Cl = *(volatile unsigned short *)(ADDR_CALIBRACAO + (contAddrMemoria - 1) * DADOS_CALIBRACAO + DADO_MEMORIA*2);	// Lê o valor de calibração anterior Cl
		medidaCalAnterior_Ca = *(volatile unsigned short *)(ADDR_CALIBRACAO + (contAddrMemoria - 1) * DADOS_CALIBRACAO + DADO_MEMORIA*3);	// Lê o valor de calibração anterior Ca
		medidaCalAnterior_pH = *(volatile unsigned short *)(ADDR_CALIBRACAO + (contAddrMemoria - 1) * DADOS_CALIBRACAO + DADO_MEMORIA*4);	// Lê o valor de calibração anterior pH

		if( abs(medidaCalAnterior_K - voltageCalA_K) < 500 )	// Se a variação entre duas calibrações é menor que 0,5, ok, senão, erro
			erroDiferencaTensoes &= ~(1 << ErrorK);
		else
			erroDiferencaTensoes |= 1 << ErrorK;

		if( abs(medidaCalAnterior_Na - voltageCalA_Na) < 500 )	// Se a variação entre duas calibrações é menor que 0,5, ok, senão, erro
			erroDiferencaTensoes &= ~(1 << ErrorNa);
		else
			erroDiferencaTensoes |= 1 << ErrorNa;

		if( abs(medidaCalAnterior_Cl - voltageCalA_Cl) < 500 )	// Se a variação entre duas calibrações é menor que 0,5, ok, senão, erro
			erroDiferencaTensoes &= ~(1 << ErrorCl);
		else
			erroDiferencaTensoes |= 1 << ErrorCl;

		if( abs(medidaCalAnterior_Ca - voltageCalA_Ca) < 500 )	// Se a variação entre duas calibrações é menor que 0,5, ok, senão, erro
			erroDiferencaTensoes &= ~(1 << ErrorCa);
		else
			erroDiferencaTensoes |= 1 << ErrorCa;

		if( abs(medidaCalAnterior_pH - voltageCalA_pH) < 500 )	// Se a variação entre duas calibrações é menor que 0,5, ok, senão, erro
			erroDiferencaTensoes &= ~(1 << ErrorpH);
		else
			erroDiferencaTensoes |= 1 << ErrorpH;

	}
	else{
		if( voltageCalB_K < 4500 || voltageCalB_K > 14000 )
			contError |= 1 << ErrorK;
		else
			contError &= ~(1 << ErrorK);

		if( voltageCalB_Na < 4500 || voltageCalB_Na > 12000 )
			contError |= 1 << ErrorNa;
		else
			contError &= ~(1 << ErrorNa);

		if( voltageCalB_Cl < 5000 || voltageCalB_Cl > 12000 )
			contError |= 1 << ErrorCl;
		else
			contError &= ~(1 << ErrorCl);

		if( voltageCalB_Ca < 3500 || voltageCalB_Ca > 10000 )
			contError |= 1 << ErrorCa;
		else
			contError &= ~(1 << ErrorCa);

		if( voltageCalB_pH < 7000 || voltageCalB_pH > 17000 )
			contError |= 1 << ErrorpH;
		else
			contError &= ~(1 << ErrorpH);


		for( unsigned int i = ADDR_CALIBRACAO + 0xEE8; i >= ADDR_CALIBRACAO + 0x780; i = i - DADOS_CALIBRACAO ){	// Faz a verificação de memória apagada

			if( *(volatile unsigned int *)(i) != 0xFFFFFFFF ){	// Se a memória foi escrita
				// Armazena no vetor os valores de calibração já feitos
				break;
			}
			contAddrMemoria--; // Caso não tenha encontrado memória, decrementa contador de endereço

		}
		medidaCalAnterior_K = *(volatile unsigned short *)(ADDR_CALIBRACAO + 0x780 + (contAddrMemoria - 1) * DADOS_CALIBRACAO);	// Lê o valor de calibração anterior K
		medidaCalAnterior_Na = *(volatile unsigned short *)(ADDR_CALIBRACAO + 0x780 + (contAddrMemoria - 1) * DADOS_CALIBRACAO + DADO_MEMORIA);	// Lê o valor de calibração anterior Na
		medidaCalAnterior_Cl = *(volatile unsigned short *)(ADDR_CALIBRACAO + 0x780 + (contAddrMemoria - 1) * DADOS_CALIBRACAO + DADO_MEMORIA*2);	// Lê o valor de calibração anterior Cl
		medidaCalAnterior_Ca = *(volatile unsigned short *)(ADDR_CALIBRACAO + 0x780 + (contAddrMemoria - 1) * DADOS_CALIBRACAO + DADO_MEMORIA*3);	// Lê o valor de calibração anterior Ca
		medidaCalAnterior_pH = *(volatile unsigned short *)(ADDR_CALIBRACAO + 0x780 + (contAddrMemoria - 1) * DADOS_CALIBRACAO + DADO_MEMORIA*4);	// Lê o valor de calibração anterior pH

		if( abs(medidaCalAnterior_K - voltageCalB_K) < 500 )	// Se a variação entre duas calibrações é menor que 0,5, ok, senão, erro
			erroDiferencaTensoes &= ~(1 << ErrorK);
		else
			erroDiferencaTensoes |= 1 << ErrorK;

		if( abs(medidaCalAnterior_Na - voltageCalB_Na) < 500 )	// Se a variação entre duas calibrações é menor que 0,5, ok, senão, erro
			erroDiferencaTensoes &= ~(1 << ErrorNa);
		else
			erroDiferencaTensoes |= 1 << ErrorNa;

		if( abs(medidaCalAnterior_Cl - voltageCalB_Cl) < 500 )	// Se a variação entre duas calibrações é menor que 0,5, ok, senão, erro
			erroDiferencaTensoes &= ~(1 << ErrorCl);
		else
			erroDiferencaTensoes |= 1 << ErrorCl;

		if( abs(medidaCalAnterior_Ca - voltageCalB_Ca) < 500 )	// Se a variação entre duas calibrações é menor que 0,5, ok, senão, erro
			erroDiferencaTensoes &= ~(1 << ErrorCa);
		else
			erroDiferencaTensoes |= 1 << ErrorCa;

		if( abs(medidaCalAnterior_pH - voltageCalB_pH) < 500 )	// Se a variação entre duas calibrações é menor que 0,5, ok, senão, erro
			erroDiferencaTensoes &= ~(1 << ErrorpH);
		else
			erroDiferencaTensoes |= 1 << ErrorpH;

	}
	if( abnormal ){	// Erro anormal, variação entre calibração A e B

		if( (voltageCalB_K - voltageCalA_K) < 1200 ||  (voltageCalB_K - voltageCalA_K) > 2100 )
			contErrorAbnormal |= 1 << ErrorK;
		else
			contErrorAbnormal &= ~(1 << ErrorK) ;

		if( (voltageCalA_Na - voltageCalB_Na) < 420 ||  (voltageCalA_Na - voltageCalB_Na) > 730 )
			contErrorAbnormal |= 1 << ErrorNa;
		else
			contErrorAbnormal &= ~(1 << ErrorNa);

		if( (voltageCalB_Cl - voltageCalA_Cl) < 540 ||  (voltageCalB_Cl - voltageCalA_Cl) > 1080 )
			contErrorAbnormal |= 1 << ErrorCl;
		else
			contErrorAbnormal &= ~(1 << ErrorCl);

		if( (voltageCalB_Ca - voltageCalA_Ca) < 660 ||  (voltageCalB_Ca - voltageCalA_Ca) > 1050 )
			contErrorAbnormal |= 1 << ErrorCa;
		else
			contErrorAbnormal &= ~(1 << ErrorCa);

		if( (voltageCalB_pH - voltageCalA_pH) < 1600 ||  (voltageCalB_pH - voltageCalA_pH) > 2800 )
			contErrorAbnormal |= 1 << ErrorpH;
		else
			contErrorAbnormal &= ~(1 << ErrorpH);

	}

	return erroDiferencaTensoes << 16 | contErrorAbnormal << 8 | contError;
}

void stateMachineError( unsigned int position, unsigned char error, unsigned char typeError ){

	switch( error ){

	case 1:

		escrita_texto(position, "K", sizeof("K"));

		break;

	case 2:

		escrita_texto(position, "Na", sizeof("Na"));

		break;

	case 3:

		escrita_texto(position, "K,Na",sizeof("K,Na"));

		break;

	case 4:

		escrita_texto(position, "Cl",sizeof("Cl"));

		break;

	case 5:

		escrita_texto(position, "K,Cl",sizeof("K,Cl"));

		break;

	case 6:

		escrita_texto(position, "K,Na",sizeof("K,Na"));

		break;

	case 7:

		escrita_texto(position, "K,Na,Cl",sizeof("K,Na,Cl"));

		break;

	case 8:

		escrita_texto(position, "Ca",sizeof("Ca"));

		break;

	case 9:

		escrita_texto(position, "K,Ca",sizeof("K,Ca"));

		break;

	case 10:

		escrita_texto(position, "Na,Ca",sizeof("Na,Ca"));

		break;

	case 11:

		escrita_texto(position, "K,Na,Ca",sizeof("K,Na,Ca"));

		break;

	case 12:

		escrita_texto(position, "Cl,Ca",sizeof("Cl,Ca"));

		break;

	case 13:

		escrita_texto(position, "K,Cl,Ca",sizeof("K,Cl,Ca"));

		break;

	case 14:

		escrita_texto(position, "Na,Cl,Ca",sizeof("Na,Cl,Ca"));

		break;

	case 15:

		escrita_texto(position, "K,Na,Cl,Ca",sizeof("K,Na,Cl,Ca"));

		break;

	case 16:

		escrita_texto(position, "pH",sizeof("pH"));

		break;

	case 17:

		escrita_texto(position, "K,pH",sizeof("K,pH"));

		break;

	case 18:

		escrita_texto(position, "Na,pH",sizeof("Na,pH"));

		break;

	case 19:

		escrita_texto(position, "K,Na,pH",sizeof("K,Na,pH"));

		break;

	case 20:

		escrita_texto(position, "Cl,pH",sizeof("Cl,pH"));

		break;

	case 21:

		escrita_texto(position, "K,Cl,pH",sizeof("K,Cl,pH"));

		break;

	case 22:

		escrita_texto(position, "Na,Cl,pH",sizeof("Na,Cl,pH"));

		break;

	case 23:

		escrita_texto(position, "K,Na,Cl,Ph",sizeof("K,Na,Cl,Ca"));

		break;

	case 24:

		escrita_texto(position, "Ca,pH",sizeof("Ca,pH"));

		break;

	case 25:

		escrita_texto(position, "K,Ca,pH",sizeof("K,Ca,pH"));

		break;

	case 26:

		escrita_texto(position, "Na,Ca,pH",sizeof("Na,Ca,pH"));

		break;

	case 27:

		escrita_texto(position, "K,Na,Ca,pH",sizeof("K,Na,Ca,pH"));

		break;

	case 28:

		escrita_texto(position, "Cl,Ca,pH",sizeof("Cl,Ca,pH"));

		break;

	case 29:

		escrita_texto(position, "K,Cl,Ca,pH",sizeof("K,Cl,Ca,pH"));

		break;

	case 30:

		escrita_texto(position, "Na,Cl,Ca,pH",sizeof("Na,Cl,Ca,pH"));

		break;

	case 31:

		escrita_texto(position, "K,Na,Cl,Ca,pH",sizeof("K,Na,Cl,Ca,pH"));

		break;

	}
	if( error != 0 ){
		if( typeError == 1 )
			escrita_texto(position + 14, "mV fora da faixa",sizeof("mV fora da faixa"));
		else if( typeError == 2 )
			escrita_texto(position + 14, "ANORMAL",sizeof("ANORMAL"));
		else
			escrita_texto(position + 14, "VARIANDO",sizeof("VARIANDO"));
	}

}

unsigned char verifyKeyBoard( void ){

	/*
	 * Função responsável por fazer a leitura de verificação do teclado e
	 * retornar o valor do teclado. Quando não tiver mais espaço vazio na fila
	 * ele lê o valor da fila do teclado e retorna este valor.
	 */

	/* Variável de escrita de espaço da fila e variável de leitura do teclado */
	int emptyKeyboard = uxQueueSpacesAvailable(fila_teclado), readQueueKeyboard = 16;	// Verifica se a fila está com dados

	if( emptyKeyboard == 0 ){	// Se espaço na fila é 0

		xQueueReceive(fila_teclado, &readQueueKeyboard, portTICK_PERIOD_MS);	// Faz a leitura da fila
		vTaskDelay(25);	// Para a task por 10ms
		flagBuz = 1;	// Seta a flag de apito

	}

	return readQueueKeyboard; // Retorna o valor do teclado pressionado
}

void initEquip( void ){

	unsigned char readKeyBoard = 0, flagEnd = 0;
	unsigned int  vPot = 0, vBat = 0;
	adc16_channel_config_t adc16ChannelConfigStruct;

	// Move MUX para a posição 3. Ele já faz esse movimento na inicialização do sistema

	desenho_inicializacao();// Desenho da tela inicial

	send_command(Display_mode_text | Display_mode_graphic); // Comando para desenho de texto e gráfico
	status(1);

	move_tripa(WAYAHOUR, SPEEDTRP1, 900);	// Move tripa na velocidade 1 por 900ms

	move_tripa(WAYAHOUR, SPEEDTRP2, 4000);	// Move tripa na velocidade 2 por 4 segundos

	move_mux(POSITION1, SPEEDMUX1);	// Move MUX para a posição 1

	if( (readKeyBoard = verifyKeyBoard()) != no ){	// Se No não está apertado

		while( !flagEnd ){
			readKeyBoard = 0;	// Zera a variável do teclado
			clear_display_text();	// Limpa a tela

			send_command(Display_mode_text);	// Envia comando para desenho apenas de display
			status(1);

			escrita_texto(10, "AUTO TESTE", sizeof("AUTO TESTE"));	// Desenha a tela de Auto teste

			escrita_texto(60, "1.Bateria de Backup", sizeof("1.Bateria de Backup")); // Escreve "1. Bateria de Backup"

			escrita_texto(120, "2.Nivel do detector de amostra", sizeof("2.Nivel do detector de amostra"));	// Escreve "2. Nível do detector de amostra"

			escrita_texto(180, "3.Tubula", sizeof("3.Tubula"));	// Escreve "3. Tubulação do Calibrador A"
			EscreveCedilhaAOTil();
			escrita_texto(190, " do Calibrador A", sizeof("o do Calibrador A"));	// Escreve "3. Tubulação do Calibrador A"

			escrita_texto(240, "4.Tubula", sizeof("4.Tubula"));	// Escreve "4. Tubulação do Calibrador B"
			EscreveCedilhaAOTil();
			escrita_texto(250, " do Calibrador B", sizeof("o do Calibrador B"));	// Escreve "3. Tubulação do Calibrador A"

			/* Verificação da tensão da bateria */

			adc16ChannelConfigStruct.channelNumber                        = 23;
			ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
			unsigned char contReadAD = 0;
			while( contReadAD < 10 ){
				contReadAD++;
				ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
				while (0U == (kADC16_ChannelConversionDoneFlag &
						ADC16_GetChannelStatusFlags(ADC0, 0)))
				{
				}
				vBat += ADC16_GetChannelConversionValue(ADC0, 0);
			}
			vBat /= contReadAD;
			if( vBat < 3000 )
				escrita_texto(117, "X", sizeof("X"));	// Escreve X indicando erro na bateria
			else
				escrita_texto(117, "OK", sizeof("OK"));// Caso a bateria esteja boa, escreve OK, senão X posição 115. Fazer a verificação da bateria por outro AD

			/* Verificação da tensão do potenciômetro */

			escrita_texto(420, "Ajuste Rxx para 800mV +- 50mV", sizeof("Ajuste Rxx para 800mV +- 50mV"));	// Escreve no final da tela "Alterar o Rxx para 800mV +- 50"

			escrita_texto(450, "NO=Sair", sizeof("NO=Sair"));

			adc16ChannelConfigStruct.channelNumber                        = 4;
			ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
			while( ( readKeyBoard = verifyKeyBoard() ) != no || ( vPot < 968 && vPot > 1018 ) ){ // Verifica o comando do teclado se é diferente de NO

				ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
				while (0U == (kADC16_ChannelConversionDoneFlag &
						ADC16_GetChannelStatusFlags(ADC0, 0)))
				{
				}
				vPot = ADC16_GetChannelConversionValue(ADC0, 0);// Mostra o nível de tensão medido no detector de amostra posição 165
				escrita_texto(169, numtolcd(vPot*8.0566, NUM), 7);
				escrita_texto(176, "mV", sizeof("mV"));
			}
			clearLine(5);	// Limpa a 5° linha de texto
			clearLine(14);	// Limpa a 14° linha de texto
			clearLine(15);	// Limpa a 15° linha de texto
			if( vPot > 968 && vPot < 1018 )
				escrita_texto(177, "OK", sizeof("OK")); // Caso esteja em 0.78 e 0.82 V, escreve OK na tela
			else
				escrita_texto(177, "X", sizeof("X")); // Caso esteja em 0.78 e 0.82 V, escreve OK na tela


			// Faz o acionamento dos motores de calibração A
			unsigned char contTestA = 0, respMoveTrip;
			while( contTestA != 3 ){		// Enquanto conTest for diferente de 3 tentativas

				move_tripa(WAYAHOUR, SPEEDTRP1, 920);	// Move motor tripa de mico por 920 milissegundos
				move_mux(POSITION3, SPEEDMUX1);		// Move motor MUX para posição 3
				move_tripa(WAYAHOUR, SPEEDTRP2, 1500);	// Move motor tripa de mico por 1240 milissegundos
				move_mux(POSITION1, SPEEDMUX1);		// Move motor MUX para posição 1
				vTaskDelay(520);	// Delay de 520ms
				move_mux(POSITION2, SPEEDMUX1);		// Move motor MUX para posição 2
				respMoveTrip = move_tripa(WAYAHOUR, SPEEDTRP4, 11000);	// Move o motor tripa de mico por 11 segundos
				if( respMoveTrip == 0 ){	// Se a resposta for igual a 0, incrementa 1 na variável contTeste
					contTestA++;
					if( contTestA == 3 )
						escrita_texto(237, "X", sizeof("X"));	// Caso a tubulação esteja ruim escreve X posição 225
				}
				else{
					escrita_texto(237, "OK", sizeof("OK"));	// Caso a tubulação esteja boa escreve OK na posição 225
					break;
				}
			}

			// Faz o acionamento dos motores de calibração B
			unsigned char contTestB = 0;
			while( contTestB != 3 ){		// Enquanto contTest for diferente de 3 tentativas

				move_tripa(WAYAHOUR, SPEEDTRP1, 920);	// Move motor tripa de mico por 920 milissegundos
				move_mux(POSITION3, SPEEDMUX1);		// Move motor MUX para posição 3
				move_tripa(WAYAHOUR, SPEEDTRP2, 3000);	// Move motor tripa de mico por 1240 milissegundos
				move_mux(POSITION1, SPEEDMUX1);		// Move motor MUX para posição 1
				vTaskDelay(520);	// Delay de 520ms
				move_mux(POSITION4, SPEEDMUX1);		// Move motor MUX para posição 4
				respMoveTrip = move_tripa(WAYAHOUR, SPEEDTRP4, 11000);	// Move o motor tripa de mico por 11 segundos
				if( respMoveTrip == 0 ){	// Se a resposta for igual a 0, incrementa 1 na variável contTeste
					contTestB++;
					if( contTestB == 3 )
						escrita_texto(297, "X", sizeof("X")); // Caso a tubulação esteja ruim escreve X posição 345
				}
				else{
					escrita_texto(297, "OK", sizeof("OK")); // Caso a tubulação esteja boa escreve OK na posição 345
					break;
				}
			}
			readKeyBoard = 0;
			// Verifica se teve algum erro no autoteste
			unsigned int timeout = 0;
			if( contTestA == 3 || contTestB == 3 || vBat < 3000 || (( vPot < 968 ) && ( vPot > 1018 )) ){
				escrita_texto(330, "Refazer o autoteste?", sizeof("Refazer o autoteste?"));
				escrita_texto(360, "YES=Sim NO=Sair", sizeof("YES=Sim NO=Sair"));
				while( timeout < 60000 ){	// Timeout de 1 minuto
					if( flag_timer ){
						flag_timer = 0;
						timeout++;
					}
					readKeyBoard = verifyKeyBoard(); // Veriifca o comando pressionado
					if( readKeyBoard == yes ){	// Se o comando pressionado for Yes, repete o autoteste
						contTestA = 0;
						contTestB = 0;
						flagEnd = 0;
						break;
					}
					else if( readKeyBoard == no ){	// Se for não, sai do autoteste
						flagEnd = 1;
						break;
					}
				}
				if( timeout >= 60000) // Caso tenha dado 1 minuto, sai do loop de autoteste
					flagEnd = 1;
			}

		}

	}
	move_tripa(WAYAHOUR, SPEEDTRP1, 920);	// Move motor tripa de mico por 920 milissegundos
	move_mux(POSITION3, SPEEDMUX1);		// Move motor MUX para posição 3
	move_tripa(WAYAHOUR, SPEEDTRP2, 3000);	// Move motor tripa de mico por 3000 milissegundos
	clear_display_text();	// Limpa a tela
}

void limpezaTubulacao( void ){

	clear_display_text();	// Limpa a tela
	// Escreve "limpeza de tubulação" na posição 215
	escrita_texto(215, "Limpeza de tubula", sizeof("Limpeza de tubula"));
	EscreveCedilhaAOTil();
	// Escreve "NO=Sair" na posição 460
	escrita_texto(460, "NO=Sair", sizeof("NO=Sair"));
	move_mux(POSITION5, SPEEDMUX1);		// Move MUX para posição 5
	move_tripa(WAYAHOUR, SPEEDTRP4, 47000);	// Move tripa por 47 segundos na velocidade 4
	move_mux(POSITION3, SPEEDMUX1);	// Move Mux para a posição 3
	move_tripa(WAYAHOUR, SPEEDTRP1, 920);	// Move tripva por 920ms na velocidade 1
	move_tripa(WAYAHOUR, SPEEDTRP4, 1000);	// Move tripa por 1 segundo na velocidade 4
	move_mux(POSITION1, SPEEDMUX1);	// Move Mux para a posição 1

	unsigned int temporizador = 1000;
	unsigned char readKeyboard = 0, flag10min = 0, minuto = 5, segundo = 59;

	escrita_texto(28, numtolcd(segundo,NUM), 3);
	escrita_texto(27, ":", sizeof(":"));
	escrita_texto(25, numtolcd(minuto-1,NUM),3);
	while( ( readKeyboard = verifyKeyBoard() ) != no ){	// Enquanto o teclado for diferente de NO

		if( flag_timer ){	// Se flag timer ativar
			flag_timer = 0;	// Zera o flag timer
			temporizador--;	// Decrementa o temporizador
			if( temporizador == 0 ){	// Se temporizador chegar a 0
				temporizador = 1000;	// Reinicia o temporizador
				segundo--;
				escrita_texto(28, numtolcd(segundo,NUM), 3);	// Escreve os segundos
				if( segundo == 0 ){	// Se segundos for igual a 0
					segundo = 59;	// Reinicia o valor do segundo
					minuto--;
					if( minuto == 0 && flag10min == 0  ){// Se o temporizador chegar a 0 e flag de 10 minutos é igual a 0
						minuto = 10;	// Temporizador recebe 10 minutos
						move_mux(POSITION2, SPEEDMUX1);	// Move Mux para a posição 2
						move_tripa(WAYAHOUR, SPEEDTRP4, 16000);	// Aciona tripa por 16 segundos na velocidade 4
						move_mux(POSITION1, SPEEDMUX1);	// Move Mux para a posição 1
						flag10min = 1;	// Seta o flag de 10 minutos
					}
					else if( minuto == 0 && flag10min == 1 )	// Se temporizador igual a 0 e deu 10 minutos
						break;
					escrita_texto(25, numtolcd(minuto-1,NUM),3);	// Escreve o minuto
					escrita_texto(28, numtolcd(segundo,NUM), 3);	// Escreve os segundos
				}
			}
		}
	}
	move_mux( POSITION3, SPEEDMUX1 );	// Move Mux para posição 3
	move_tripa( WAYAHOUR, SPEEDTRP1, 920 );	// Aciona tripa por 920ms na velocidade 1
	move_tripa( WAYAHOUR, SPEEDTRP4, 1000 );	// Move tripa por 1 segundo na velocidade 4
	vTaskDelay(520);// Delay de 520 ms
	move_tripa( WAYHOUR, SPEEDTRP1, 920 );	// Aciona tripa por 920ms na velocidade 1 no sentido horário
	move_tripa( WAYAHOUR, SPEEDTRP1, 920 );// Aciona tripa por 920ms na velocidade 1 no sentido anti-horário
	move_mux( POSITION3, SPEEDMUX1 ); // Move Mux para posição 3
	calibA(1);	// Função lavando calib(1)
}

void condicionamento( void ){

	// Declaraçãod das variáveis
	unsigned char estado = 0, minuto = 5, segundo = 59, respMotor = 0, readKeyboard = 0;
	unsigned int temporizador = 0, timeout = 0;

	clear_display_text();	// Apaga a tela

	move_tripa(WAYAHOUR, SPEEDTRP1, 920);	// Move tripa por 920ms velocidade 1

	move_mux(POSITION3, SPEEDMUX1);		// Move mux para a posição 3

	move_tripa(WAYAHOUR, SPEEDTRP2, 5000);		// Move tripa por 5 segundos velocidade 1

	escrita_texto(8, "CONDICIONAMENTO", sizeof("CONDICIONAMENTO"));

	writeLine(13);

	escrita_texto(211, "Levante a sonda para aspirar", sizeof("Levante a sonda para aspirar"));		// Escreve “Levante a sonda para aspirar” na linha 210

	escrita_texto( 450, "YES=Asp NO=Sair", sizeof("YES=Asp NO=Sair"));	// Escreve Comandos na tela
	while( 1 ){		switch(estado){

	case 0:	// Estado 0. Início movimento dos motores

		if( agulhaFechada ){	// Se sonda fechada
			if( flag_timer ){	// Se flag timer igual a 1
				flag_timer = 0;	// Flag timer recebe 0
				timeout++;	// Incrementa timeout de 1
				if( timeout >= 60000 || (readKeyboard = verifyKeyBoard()) == no  ){	// Se timeout é maior ou igual a 60000 (1 minuto) ou teclado igual a No

					move_mux(POSITION1, SPEEDMUX1);	// Move mux para a posição 1
					clear_display_text();	// Limpa a tela
					telaManutencao();	// Escreve tela de Manutenção
					return;

				}
			}
		}
		else if( agulhaAberta ){		// Se Sonda está aberta
			estado = 1;		// Estado recebe 1
			timeout = 0;	// Timeout recebe 0
		}


		break;

	case 1:	// Estado 1. Leitura da sonda e verificação de timeout
		if( flag_timer ){	// Se flag timer igual a 1
			flag_timer = 0;	// Flag timer recebe 0
			timeout++;	// Incrementa timeout de 1
			if( timeout >= 60000  ){	// Se timeout é maior ou igual a 60000 (1 minuto) ou teclado igual a No

				move_mux(POSITION1, SPEEDMUX1);	// Move mux para a posição 1
				clear_display_text();	// Limpa a tela
				telaManutencao();	// Escreve tela de Manutenção
				return;

			}
		}
		else if( (readKeyboard = verifyKeyBoard()) == yes ){ 	//
			escrita_texto(401, "Aspirando", sizeof("Aspirando"));		// Escreve “Aspirando“ na linha 390
			move_tripa(WAYAHOUR,SPEEDTRP1,2400);	// Aciona tripa por 2,4 segundos na velocidade 1
			clearLine(7);	// Apaga a linha 7
			escrita_texto(215, "Favor abaixar a Sonda", sizeof("Favor abaixar a Sonda"));	// Escreve “Favor abaixar a Sonda” na posição 210
			while( agulhaAberta );	// Enquanto a sonda está aberta
			clearLine(7);
			respMotor = move_tripa(WAYAHOUR,SPEEDTRP4,15000);	// Aciona tripa por 15 segundos
			if( respMotor == 1 && agulhaFechada ){	// Se detectou líquido
				estado = 3;
				temporizador = 1000;	// Temporizador recebe 1000 para contagem de 1 segundo
				minuto = 5;	// Minuto recebe 5
				segundo = 59;	// Segundo recebe 59
				escrita_texto(28, numtolcd(segundo,NUM), 3);	// Escreve segundo
				escrita_texto(27, ":", sizeof(":"));	// Escreve :
				escrita_texto(25, numtolcd(minuto-1,NUM),3);	// Escreve minutos - 1
			}
			else{

				estado = 5;	// Estado de erro de detecção de líqudo
				if( agulhaAberta ){	// Se a agulha está aberta
					escrita_texto(395, "Favor baixar a agulha", sizeof("Favor baixar a agulha"));	// Escreve "Favor baixar a agulha"
					while( agulhaAberta );	// Aguarda até a agulha ser abaixada
				}

			}
		}
		else if( (readKeyboard = verifyKeyBoard()) == no ){	// Se teclado igual a No
			move_mux(POSITION1, SPEEDMUX1);	// Move mux para a posição 1
			clear_display_text();	// Limpa a tela
			telaManutencao();	// Escreve tela de Manutenção
			return;
		}

		break;

	case 3:	// Se detectou líquido começa a contagem de tempo

		if( minuto > 0 && (readKeyboard = verifyKeyBoard()) != no ){// Enquanto minuto for maior que 0 e teclado diferente de No
			if( flag_timer ){	// Se flag timer ativar
				flag_timer = 0;	// Zera o flag timer
				temporizador--;	// Decrementa o temporizador
				if( temporizador == 0 ){	// Se temporizador chegar a 0
					temporizador = 1000;	// Reinicia o temporizador
					segundo--;
					escrita_texto(28, numtolcd(segundo,NUM), 3);	// Escreve os segundos
					if( segundo == 0 ){	// Se segundos for igual a 0
						segundo = 59;	// Reinicia o valor do segundo
						minuto--;	// Minuto decrementa
						if( minuto == 0 ){	// Se temporizador igual a 0 e deu 10 minutos
							estado = 4;
						}
						escrita_texto(25, numtolcd(minuto-1,NUM),3);	// Escreve o minuto
						escrita_texto(28, numtolcd(segundo,NUM), 3);	// Escreve os segundos
					}
				}
			}
		}
		else{
			estado = 4;	// Estado para funcionamento correto
		}

		break;

	case 4:	// Estado 4. Temporizador terminou ou teclado No foi pressionado

		respMotor = calibA(1);	// Lavando (calib(1)).Faz verificação de líquido. Passa 3 vezes
		if( respMotor == 0 || respMotor == 2 ){	// Se identificou líquido na lavagem
			move_mux(POSITION1, SPEEDMUX1);	// Move mux para a posição 1
			clear_display_text();	// Limpa a tela
			telaManutencao();	// Escreve tela de Manutenção
			return;
		}

		break;

	case 5:	// Estado 5. Falta de detecção de líquido

		respMotor = calibA(1);	// Lavando (calib(1)).Faz verificação de líquido. Passa 3 vezes
		if( respMotor == 2 || respMotor == 0 ){	// Se não identificou líquido na lavagem
			move_tripa(WAYAHOUR, SPEEDTRP1, 920);	// Move tripa por 920ms velocidade 1
			move_mux(POSITION3,SPEEDMUX1);	// Move mux para a posição 3
			move_tripa(WAYAHOUR, SPEEDTRP4, 5000);	// Move tripa por 5 segundos na velocidade 4
			move_mux(POSITION1, SPEEDMUX1);	// Move mux para a posição 1
			writeLine(13);	// Desenha na linha 13
			clearLine(8);
			escrita_texto(210, "Sem amostra. Aspirar novamente?", sizeof("Sem amostra. Aspirar novamente?"));	// Escreve “Sem amostra. Aspirar novamente?”
			estado = 7;	// Estado de verificação de botão para retornar ao início
		}


		break;

	case 7:	// Estado 7. Verificação de botão para retornar ao estado inicial

		readKeyboard = verifyKeyBoard();
		if( readKeyboard == yes ){
			clearLine(7);
			clearLine(8);
			escrita_texto(210, "Levante a sonda para aspirar", sizeof("Levante a sonda para aspirar"));		// Escreve “Levante a sonda para aspirar” na linha 210
			estado = 1;	// Verificação de sonda aberta
		}
		else if( readKeyboard == no ){

			clear_display_text();	// Limpa a tela
			telaManutencao();	// Escreve tela de Manutenção
			return;

		}
		break;
	}

	}

}

void desproteinizacao( void ){

	clear_display_text();	// Apaga a tela
	escrita_texto(7, "DESPROTEINIZA", sizeof("DESPROTEINIZA"));	// Escreve "Desproteinização em andamento"
	EscreveCedilhaAOTil();
	writeLine(13);	// Escreve desenho na tela
	// Escreve "Dissolva completamente a enzima e abra a agulha para aspirar
	escrita_texto(210,"Dissolva completamente a enzima e abra a agulha para aspirar", sizeof("Dissolva completamente a enzima e abra a agulha para aspirar"));
	escrita_texto(450, "Yes=ASP NO=Sair", sizeof("Yes=ASP NO=Sair"));	// Escreve Yes=ASP NO=Sair

	// Declaração das variáveis
	unsigned char estado = 0, minuto = 30, segundo = 59, respMotor = 0, readKeyboard = 0;
	unsigned int temporizador = 0, timeout = 0;

	while(1){

		switch(estado){	// Veriicação de agulha aberta
		case 0:

			if( flag_timer ){	// Se flag timer igual a 1
				flag_timer = 0;	// Flag timer recebe 0
				timeout++;	// Incrementa timeout de 1
				if( timeout >= 60000 || (readKeyboard = verifyKeyBoard()) == no ){	// Se timeout é maior ou igual a 60000 (1 minuto) ou teclado igual a No

					move_mux(POSITION1, SPEEDMUX1);	// Move mux para a posição 1
					clear_display_text();	// Limpa a tela
					telaManutencao();	// Escreve tela de Manutenção
					return;

				}
			}
			else if( agulhaAberta && (readKeyboard = verifyKeyBoard()) == yes ){

				clearLine(7);	// Apaga a linha 7
				clearLine(8);	// Apaga a linha 8
				escrita_texto(210, "Aspirando solu", sizeof("Aspirando solu"));
				// Comandos para escrita de ção
				EscreveCedilhaAOTil();
				escrita_texto(228, "desproteinizante", sizeof("desproteinizante"));
				move_tripa(WAYAHOUR, SPEEDTRP1, 4000);	// Aciona tripa por 4 segundos na velocidade 1
				vTaskDelay(500);	// Delay de 500ms
				respMotor = move_tripa(WAYAHOUR, SPEEDTRP4, 15000); // Aciona tripa por 15 segundos na velocidade 4
				vTaskDelay(500);	// Delay de 500ms
				move_tripa(WAYAHOUR, SPEEDTRP1, 300);	// Aciona tripa por 300ms na velocidade 1
				if( respMotor == 1 ){	// Se detectou líquido
					escrita_texto(210, "Favor baixar a agulha", sizeof("Favor baixar a agulha"));	// Escreve "Favor baixar a agulha"
					while( agulhaAberta );	// Enquanto a agulha está aberta, bloqueia o código
					if( agulhaFechada ){

						// Escreve "Desproteinização em andamento"
						escrita_texto(210, "Desproteiniza", sizeof("Desproteiniza"));
						EscreveCedilhaAOTil();
						escrita_texto(232, " em andamento", sizeof(" em andamento"));
						escrita_texto(28, numtolcd(segundo,NUM), 3);	// Escreve segundo
						escrita_texto(27, ":", sizeof(":"));	// Escreve :
						escrita_texto(25, numtolcd(minuto-1,NUM),3);	// Escreve minutos - 1
						estado = 1;	// Estado vai para temporizador

					}
				}
				else{


					if( agulhaAberta ){	// Se a agulha está aberta
						escrita_texto(395, "Favor baixar a agulha", sizeof("Favor baixar a agulha"));	// Escreve "Favor baixar a agulha"
						while( agulhaAberta );	// Aguarda até a agulha ser abaixada
					}
					writeLine(13);
					// Escreve "Falta de Sol. Desproteinizante"
					escrita_texto(210, "Falta de Sol. Desproteinizante", sizeof( "Falta de Sol. Desproteinizante"));
					escrita_texto(240,"Aspirar Novamente?", sizeof("Aspirar Novamente?"));	// Escreve "Aspirar novamente?
					estado = 2; // Estado de verificação de comandos

				}
			}
			break;

		case 1:	// Temporizador

			if( minuto > 0 && (readKeyboard = verifyKeyBoard()) != no ){// Enquanto minuto for maior que 0 e teclado diferente de No
				if( flag_timer ){	// Se flag timer ativar
					flag_timer = 0;	// Zera o flag timer
					temporizador--;	// Decrementa o temporizador
					if( temporizador == 0 ){	// Se temporizador chegar a 0
						temporizador = 1000;	// Reinicia o temporizador
						segundo--;
						escrita_texto(28, numtolcd(segundo,NUM), 3);	// Escreve os segundos
						if( segundo == 0 ){	// Se segundos for igual a 0
							segundo = 59;	// Reinicia o valor do segundo
							minuto--;	// Minuto decrementa
							if( minuto == 0 ){	// Se temporizador igual a 0 e deu 10 minutos
								estado = 4;
							}
							escrita_texto(25, numtolcd(minuto-1,NUM),3);	// Escreve o minuto
							escrita_texto(28, numtolcd(segundo,NUM), 3);	// Escreve os segundos
						}
					}
				}
			}
			else{

				clear_display_text();	// Limpa a tela
				telaManutencao();	// Desenha tela de manutenção
				respMotor = calibA(1);	// Lavando (calib(1)).Faz verificação de líquido. Passa 3 vezes
				return;	// Retorna a função

			}

			break;

		case 2:	// Verificação de comandos

			readKeyboard = verifyKeyBoard();	// Lê o teclado
			if( readKeyboard == no ){	// Se teclado igual a No
				respMotor = calibA(1);	// Lavando (calib(1)).Faz verificação de líquido. Passa 3 vezes
				if( respMotor == 0 || respMotor == 2 ){	// Se não identificou líquido na lavagem
					clear_display_text();	// Limpa a tela
					telaManutencao();	// Desenha tela de manutenção
					return;	// Retorna a função
				}
			}
			else if( readKeyboard == yes ){	// Senão se teclado igual a yes
				estado = 0;// Estado recebe 0, leitura da sonda e aspiração do desproteinizante
				// Escreve "Dissolva completamente a enzima e abra a agulha para aspirar
				escrita_texto(210,"Dissolva completamente a enzima e abra a agulha para aspirar", sizeof("Dissolva completamente a enzima e abra a agulha para aspirar"));
				escrita_texto(450, "Yes=ASP NO=Sair", sizeof("Yes=ASP NO=Sair"));	// Escreve Yes=ASP NO=Sair
			}

			break;

		}

	}
}

void telaManutencao( void ){

	escrita_texto(11, "MANUTEN", sizeof("MANUTEN"));	// Escreve "MANUTENÇÃO" na posição 11
	// Comandos para escrita de ção
	EscreveCedilhaAOTil();
	escrita_texto(60, "1 CONDICIONAMENTO", sizeof("1 CONDICIONAMENTO"));	// Escreve "1 CONDICIONAMENTO"
	escrita_texto(120, "2 DESPROTEINIZA", sizeof("2 DESPROTEINIZA"));	// Escreve "2 DESPROTEINIZAÇÃO"
	// Comandos para escrita de ção
	EscreveCedilhaAOTil();
	escrita_texto(180, "3 LAVAGEM INTERNA", sizeof("3 LAVAGEM INTERNA"));	// Escreve "3 LAVAGEM INTERNA"
	escrita_texto(240, "4 LIMPEZA DA TUBULA", sizeof("4 LIMPEZA DA TUBULA"));	// Escreve "4 LIMPEZA DA TUBULAÇÃO"
	// Comandos para escrita de ção
	EscreveCedilhaAOTil();
	escrita_texto(450, "1-4=Selecionar NO=Sair", sizeof("1-4=Selecionar NO=Sair"));	// Escreve "1-4=Selecionar NO=Sair"

}

void EscreveCedilhaAOTil( void ){

	send_data(0x60);	// Comando para ç
	send_command(0xC0);
	status(1);
	send_data(0x81);	// Comando para Ã
	send_command(0xC0);
	status(1);
	send_data(0x2F);	// Comando para O
	send_command(0xC0);
	status(1);

}

char *ConverteNumParaLcd( unsigned char qtdDigitos, unsigned char qtdCasasDecimais, unsigned long num ){
	/*
	 * Faz a conversão de um número qualquer para o código usado no LCD. É possível definir até 5
	 * dígitos e a quantidade de casas decimais que serão mostrados no LCD.
	 * A soma com 0x30 é para converter o número para o código ASCII
	 */

	switch(qtdDigitos){

	case 1:	// 1 Dígito

		data[0] = num + 0x30;// data[0] recebe num
		// data[1 - 5] recebe 0
		data[1] = 0;
		data[2] = 0;
		data[3] = 0;
		data[4] = 0;
		data[5] = 0;

		break;

	case 2:	// 2 Dígitos

		data[0] = num / 10 + 0x30;	// data[0] recebe num dividido por 10 mais 0x30
		if( qtdCasasDecimais == 1 ){	// Se quantidade de casas decimais for diferente de 0
			data[1] = 0x2E;	// data[1] recebe 0x2E, . em código ASCII
			data[2] = num % 10 + 0x30;	// data[2] recebe num percent 10 (resto da divisão) mais 0x30
		}
		else{	// Senão se não tem casa decimal
			data[1] = num % 10 + 0x30;	// data[2] recebe num percent 10 (resto da divisão) mais 0x30
			data[2] = 0;
		}
		data[3] = 0;
		data[4] = 0;
		data[5] = 0;
		break;

	case 3:	// 3 Dígitos

		data[0] = num / 100 + 0x30;	// data[0] recebe num dividido por 100 mais 0x30
		if( qtdCasasDecimais == 1 ){	// Se quantidade de casas decimais for igual a 1
			data[1] = num % 100 / 10 + 0x30;	// data[1] recebe num percent 100 dividido por 10 mais 0x30
			data[2] = 0x2E;	// data[2] recebe 0x2E, . em código ASCII
			data[3] = num % 100 % 10 + 0x30;	// data[3] recebe num percent 100 percent 10 mais 0x30
		}
		else if( qtdCasasDecimais == 2 ){	// Senão se quantidade de casas decimais igual a 2
			data[1] = 0x2E;	// data[2] recebe 0x2E, . em código ASCII
			data[2] = num % 100 / 10 + 0x30;	// data[1] recebe num percent 100 dividido por 10 mais 0x30
			data[3] = num % 100 % 10 + 0x30;	// data[3] recebe num percent 100 percent 10 mais 0x30
		}
		else{	// Senão se não tem casa decimal
			data[1] = num % 100 / 10 + 0x30;	// data[1] recebe num percent 100 dividido por 10 mais 0x30
			data[2] = num % 100 % 10 + 0x30;	// data[3] recebe num percent 100 percent 10 mais 0x30
			data[3] = 0;
		}
		data[4] = 0;
		data[5] = 0;

		break;

	case 4:	// 4 Dígitos

		data[0] = num / 1000 + 0x30;	// data[0] recebe num dividido por 1000 mais 0x30
		if( qtdCasasDecimais == 1 ){	// Se quantidade de casas decimais for igual a 1
			data[1] = num % 1000 / 100 + 0x30;	// data[1] recebe num percent 1000 percent 100 mais 0x30
			data[2] = num % 1000 % 100 / 10 + 0x30;	// data[2] recebe num percent 1000 percent 100 dividido por 10 mais 0x30
			data[3] = 0x2E;	// data[3] recebe 0x2E, . em código ASCII
			data[4] = num % 1000 % 100 % 10 + 0x30;	// data[4] recebe num percent 1000 percent 100 percent 10 mais 0x30
		}
		else if( qtdCasasDecimais == 2 ){	// Senão se quantidade de casas decimais igual a 2
			data[1] = num % 1000 / 100 + 0x30;	// data[1] recebe num percent 1000 percent 100 mais 0x30
			data[2] = 0x2E;	// data[2] recebe 0x2E, . em código ASCII
			data[3] = num % 1000 % 100 / 10 + 0x30;	// data[3] recebe num percent 1000 percent 100 dividido por 10 mais 0x30
			data[4] = num % 1000 % 100 % 10 + 0x30;	// data[4] recebe num percent 1000 percent 100 percent 10 mais 0x30
		}
		else if( qtdCasasDecimais == 3 ){	// Senão se quantidade de casas decimais igual a 3
			data[1] = 0x2E;	// data[1] recebe 0x2E, . em código ASCII
			data[2] = num % 1000 / 100 + 0x30;	// data[2] recebe num percent 1000 percent 100 mais 0x30
			data[3] = num % 1000 % 100 / 10 + 0x30;	// data[3] recebe num percent 1000 percent 100 dividido por 10 mais 0x30
			data[4] = num % 1000 % 100 % 10 + 0x30;	// data[4] recebe num percent 1000 percent 100 percent 10 mais 0x30
		}
		else{	// Senão se não tem casa decimal
			data[1] = num % 1000 / 100 + 0x30;	// data[1] recebe num percent 1000 percent 100 mais 0x30
			data[2] = num % 1000 % 100 / 10 + 0x30;	// data[2] recebe num percent 1000 percent 100 dividido por 10 mais 0x30
			data[3] = num % 1000 % 100 % 10 + 0x30;	// data[4] recebe num percent 1000 percent 100 percent 10 mais 0x30
			data[4] = 0;
		}
		data[5] = 0;

		break;

	case 5:	// 5 Dígitos

		data[0] = num / 10000 + 0x30;	// data[0] recebe num dividido por 10000 mais 0x30
		if( qtdCasasDecimais == 1 ){	// Se quantidade de casas decimais for igual a 1
			data[1] = num % 10000 / 1000 + 0x30;	// data[1] recebe num percent 10000 percent 1000 mais 0x30
			data[2] = num % 10000 % 1000 / 100 + 0x30;	// data[2] recebe num percent 10000 percent 1000 dividido por 100 mais 0x30
			data[3] = num % 10000 % 1000 % 100 / 10 + 0x30;	// data[3] recebe num percent 10000 percent 1000 percent 100 dividido por 10 mais 0x30
			data[4] = 0x2E;	// data[4] recebe 0x2E, . em código ASCII
			data[5] = num % 10000 % 1000 % 100 % 10 + 0x30;	// data[5] recebe num percent 10000 percent 1000 percent 100 percent 10 mais 0x30
		}
		else if( qtdCasasDecimais == 2 ){	// Senão se quantidade de casas decimais igual a 2
			data[1] = num % 10000 / 1000 + 0x30;	// data[1] recebe num percent 10000 percent 1000 mais 0x30
			data[2] = num % 10000 % 1000 / 100 + 0x30;	// data[2] recebe num percent 10000 percent 1000 dividido por 100 mais 0x30
			data[3] = 0x2E;	// data[3] recebe 0x2E, . em código ASCII
			data[4] = num % 10000 % 1000 % 100 / 10 + 0x30;	// data[4] recebe num percent 10000 percent 1000 percent 100 dividido por 10 mais 0x30
			data[5] = num % 10000 % 1000 % 100 % 10 + 0x30;	// data[5] recebe num percent 10000 percent 1000 percent 100 percent 10 mais 0x30
		}
		else if( qtdCasasDecimais == 3 ){	// Senão se quantidade de casas decimais igual a 3
			data[1] = num % 10000 / 1000 + 0x30;	// data[1] recebe num percent 10000 percent 1000 mais 0x30
			data[2] = 0x2E;	// data[2] recebe 0x2E, . em código ASCII
			data[3] = num % 10000 % 1000 / 100 + 0x30;	// data[3] recebe num percent 10000 percent 1000 dividido por 100 mais 0x30
			data[4] = num % 10000 % 1000 % 100 / 10 + 0x30;	// data[4] recebe num percent 10000 percent 1000 percent 100 dividido por 10 mais 0x30
			data[5] = num % 10000 % 1000 % 100 % 10 + 0x30;	// data[5] recebe num percent 10000 percent 1000 percent 100 percent 10 mais 0x30
		}
		else if( qtdCasasDecimais == 4 ){	// Senão se quantidade de casas decimais igual a 4
			data[1] = 0x2E;	// data[1] recebe 0x2E, . em código ASCII
			data[2] = num % 10000 / 1000 + 0x30;	// data[2] recebe num percent 10000 percent 1000 mais 0x30
			data[3] = num % 10000 % 1000 / 100 + 0x30;	// data[3] recebe num percent 10000 percent 1000 dividido por 100 mais 0x30
			data[4] = num % 10000 % 1000 % 100 / 10 + 0x30;	// data[4] recebe num percent 10000 percent 1000 percent 100 dividido por 10 mais 0x30
			data[5] = num % 10000 % 1000 % 100 % 10 + 0x30;	// data[5] recebe num percent 10000 percent 1000 percent 100 percent 10 mais 0x30
		}
		else{	// Senão se não tem casa decimal
			data[1] = num % 10000 / 1000 + 0x30;	// data[2] recebe num percent 10000 percent 1000 mais 0x30
			data[2] = num % 10000 % 1000 / 100 + 0x30;	// data[3] recebe num percent 10000 percent 1000 dividido por 100 mais 0x30
			data[3] = num % 10000 % 1000 % 100 / 10 + 0x30;	// data[4] recebe num percent 10000 percent 1000 percent 100 dividido por 10 mais 0x30
			data[4] = num % 10000 % 1000 % 100 % 10 + 0x30;	// data[5] recebe num percent 10000 percent 1000 percent 100 percent 10 mais 0x30
			data[5] = 0;
		}

		break;
	}
	return data;
}

char ContaCaracteres( void ){

	/*
	 * Função que retorna quantos caracteres foram escritos para
	 * automatizar a escrita dos dados salvos no vetor de data
	 */
	for( unsigned char i = 0; i < 6; i ++ )
		if( data[i] == 0 )
			return i;
	return 6;

}

void AjustaHora( void ){

}

void AjustaCorrelacao( void ){

	/*
	 * Mínimo e máximo de valores: -100 até 100
	 * Define os valores de correlação para slope e intercept
	 * Área de memória utilizada: Slope - 0xE2000 até 0xE20010
	 * Área de memória utilizada: Intercept - 0xE2014 até 0xE2024
	 */
	// Verifica se há algum dado salvo na memória para cada um dos elementos
	float slopeEletrodos[5], interceptEletrodos[5];
	unsigned int timeout = 0, posicaoTexto[10];
	unsigned char estadoCorrelacao = 0, contOk = 0, readTeclado = 0, tamanhoDigito[10];
	float numeroInit[10], *numero;

	// Atualização dos números anteriores
	for( int i = 0; i < 10; i++){
		if( *(volatile unsigned int *)(ADDR_CONFIGURACAO + i*4) != 0xFFFFFFFF ){
			numeroInit[i] = *(volatile float *)(ADDR_CONFIGURACAO + i*4);
		}
	}

	// Verificação se há dados salvos de Slope para o eletrodo K
	if( *(volatile unsigned int *)(ADDR_CONFIGURACAO + ADDR_SLOPE_K) != 0xFFFFFFFF )
		slopeEletrodos[0] = *(volatile float *)(ADDR_CONFIGURACAO + ADDR_SLOPE_K);
	else
		slopeEletrodos[0] = 1;

	// Verificação se há dados salvos de Slope para o eletrodo Na
	if( *(volatile unsigned int *)(ADDR_CONFIGURACAO + ADDR_SLOPE_Na) != 0xFFFFFFFF )
		slopeEletrodos[1] = *(volatile float *)(ADDR_CONFIGURACAO + ADDR_SLOPE_Na);
	else
		slopeEletrodos[1] = 1;

	// Verificação se há dados salvos de Slope para o eletrodo Cl
	if( *(volatile unsigned int *)(ADDR_CONFIGURACAO + ADDR_SLOPE_Cl) != 0xFFFFFFFF )
		slopeEletrodos[2] = *(volatile float *)(ADDR_CONFIGURACAO + ADDR_SLOPE_Cl);
	else
		slopeEletrodos[2] = 1;

	// Verificação se há dados salvos de Slope para o eletrodo Ca
	if( *(volatile unsigned int *)(ADDR_CONFIGURACAO + ADDR_SLOPE_Ca) != 0xFFFFFFFF )
		slopeEletrodos[3] = *(volatile float *)(ADDR_CONFIGURACAO + ADDR_SLOPE_Ca);
	else
		slopeEletrodos[3] = 1;

	// Verificação se há dados salvos de Slope para o eletrodo pH
	if( *(volatile unsigned int *)(ADDR_CONFIGURACAO + ADDR_SLOPE_pH) != 0xFFFFFFFF )
		slopeEletrodos[4] = *(volatile float *)(ADDR_CONFIGURACAO + ADDR_SLOPE_pH);
	else
		slopeEletrodos[4] = 1;

	// Verificação se há dados salvos de intercept para o eletrodo K
	if( *(volatile unsigned int *)(ADDR_CONFIGURACAO + ADDR_INTERCEPT_K) != 0xFFFFFFFF )
		interceptEletrodos[0] = *(volatile float *)(ADDR_CONFIGURACAO + ADDR_INTERCEPT_K);
	else
		interceptEletrodos[0] = 0;

	// Verificação se há dados salvos de intercept para o eletrodo Na
	if( *(volatile unsigned int *)(ADDR_CONFIGURACAO + ADDR_INTERCEPT_Na) != 0xFFFFFFFF )
		interceptEletrodos[1] = *(volatile float *)(ADDR_CONFIGURACAO + ADDR_INTERCEPT_Na);
	else
		interceptEletrodos[1] = 0;

	// Verificação se há dados salvos de intercept para o eletrodo Cl
	if( *(volatile unsigned int *)(ADDR_CONFIGURACAO + ADDR_INTERCEPT_Cl) != 0xFFFFFFFF )
		interceptEletrodos[2] = *(volatile float *)(ADDR_CONFIGURACAO + ADDR_INTERCEPT_Cl);
	else
		interceptEletrodos[2] = 0;

	// Verificação se há dados salvos de intercept para o eletrodo Ca
	if( *(volatile unsigned int *)(ADDR_CONFIGURACAO + ADDR_INTERCEPT_Ca) != 0xFFFFFFFF )
		interceptEletrodos[3] = *(volatile float *)(ADDR_CONFIGURACAO + ADDR_INTERCEPT_Ca);
	else
		interceptEletrodos[3] = 0;

	// Verificação se há dados salvos de intercept para o eletrodo pH
	if( *(volatile unsigned int *)(ADDR_CONFIGURACAO + ADDR_INTERCEPT_pH) != 0xFFFFFFFF )
		interceptEletrodos[4] = *(volatile float *)(ADDR_CONFIGURACAO + ADDR_INTERCEPT_pH);
	else
		interceptEletrodos[4] = 0;

	while( 1 ){
		readTeclado = verifyKeyBoard();
		switch( estadoCorrelacao ){	// Máquina de estado para correlação
		case 0:


			for( int i = 0; i < 10; i++){	// Faz a verificação do valor salvo na memória, se é maior ou menor que 10
				if( i < 5 ){
					if( abs(slopeEletrodos[i]) >= 10 ){	// Se for maior que 10
						tamanhoDigito[i] = 4;	// Serão 4 dígitos escritos
						posicaoTexto[i] = 103 + 60*i;	// Posição inicial do desenho mas o pulo de duas linhas
					}
					else{
						tamanhoDigito[i] = 3;	// Serão 3 dígitos escritos
						posicaoTexto[i] = 104 + 60*i;	// Posição inicial do desenho mas o pulo de duas linhas
					}
				}
				else{
					if( abs(interceptEletrodos[i % 5]) >= 10 ){	// Faz a verificação do valor salvo na memória, se é maior ou menor que 10
						tamanhoDigito[i] = 4;	// Serão 4 dígitos escritos
						posicaoTexto[i] = 113 + 60*(i % 5) ;	// Posição inicial do desenho mas o pulo de duas linhas
					}
					else{
						tamanhoDigito[i] = 3;	// Serão 3 dígitos escritos
						posicaoTexto[i] = 114 + 60*(i % 5);	// Posição inicial do desenho mas o pulo de duas linhas
					}
				}
			}

			// Escrita configuração
			escrita_texto(9, "CONFIGURA", sizeof("CONFIGURA"));
			EscreveCedilhaAOTil();

			escrita_texto(73, "SLOPE", sizeof("SLOPE")); // Escreve "SLOPE" na linha 3

			escrita_texto(83, "INTERC", sizeof("INTERC")); // Escreve "INTERC" na linha 3

			writeLine(13);	// Escrita de traço na linha 13
			// Escrtia do eletrodo K e dos valores salvos na flash
			escrita_texto(96, "K", sizeof("K"));
			if( slopeEletrodos[0] < 0 ){	// Se a posição da memória é negativa
				escrita_texto( 102, "-", sizeof("-"));	// Escreve "-"
			}
			if( interceptEletrodos[0] < 0 ){	// Se a posição da memória é negativa
				escrita_texto( 112, "-", sizeof("-"));	// Escreve "-"
			}
			// Faz a verificação do tamanho do dígito
			escrita_texto(posicaoTexto[0], ConverteNumParaLcd(tamanhoDigito[0], 2,(unsigned int)(abs(slopeEletrodos[0] * 100))), ContaCaracteres()+1);	// Slope
			escrita_texto(posicaoTexto[5], ConverteNumParaLcd(tamanhoDigito[5], 2,(unsigned int)(abs(interceptEletrodos[0] * 100))), ContaCaracteres()+1);	// Intercept

			// Escrtia do eletrodo Na e dos valores salvos na flash
			escrita_texto(156, "Na", sizeof("Na"));

			if( slopeEletrodos[1] < 0 ){	// Se a posição da memória é negativa
				escrita_texto( 162, "-", sizeof("-"));	// Escreve "-"
			}
			if( interceptEletrodos[1] < 0 ){	// Se a posição da memória é negativa
				escrita_texto( 172, "-", sizeof("-"));	// Escreve "-"
			}
			escrita_texto(posicaoTexto[1], ConverteNumParaLcd(tamanhoDigito[1], 2, (unsigned int)(abs(slopeEletrodos[1] * 100))), ContaCaracteres()+1);	// Slope
			escrita_texto(posicaoTexto[6], ConverteNumParaLcd(tamanhoDigito[6], 2, (unsigned int)(abs(interceptEletrodos[1] * 100))), ContaCaracteres()+1);	// Intercept

			// Escrtia do eletrodo Cl e dos valores salvos na flash
			escrita_texto(216, "Cl", sizeof("Cl"));
			if( slopeEletrodos[2] < 0 ){	// Se a posição da memória é negativa
				escrita_texto( 222, "-", sizeof("-"));	// Escreve "-"
			}
			if( interceptEletrodos[2] < 0 ){	// Se a posição da memória é negativa
				escrita_texto( 232, "-", sizeof("-"));	// Escreve "-"
			}
			escrita_texto(posicaoTexto[2], ConverteNumParaLcd(tamanhoDigito[2], 2, (unsigned int)(abs(slopeEletrodos[2] * 100))), ContaCaracteres()+1);	// Slope
			escrita_texto(posicaoTexto[7], ConverteNumParaLcd(tamanhoDigito[7], 2, (unsigned int)(abs(interceptEletrodos[2] * 100))), ContaCaracteres()+1);	// Intercept

			// Escrtia do eletrodo Ca e dos valores salvos na flash
			escrita_texto(276, "Ca", sizeof("Ca"));
			if( slopeEletrodos[3] < 0 ){	// Se a posição da memória é negativa
				escrita_texto( 282, "-", sizeof("-"));	// Escreve "-"
			}
			if( interceptEletrodos[3] < 0 ){	// Se a posição da memória é negativa
				escrita_texto( 292, "-", sizeof("-"));	// Escreve "-"
			}
			escrita_texto(posicaoTexto[3], ConverteNumParaLcd(tamanhoDigito[3], 2, (unsigned int)(abs(slopeEletrodos[3] * 100))), ContaCaracteres()+1);	// Slope
			escrita_texto(posicaoTexto[8], ConverteNumParaLcd(tamanhoDigito[8], 2, (unsigned int)(abs(interceptEletrodos[3] * 100))), ContaCaracteres()+1);	// Intercept

			// Escrtia do eletrodo pH e dos valores salvos na flash
			escrita_texto(336, "pH", sizeof("pH"));
			if( slopeEletrodos[4] < 0 ){	// Se a posição da memória é negativa
				escrita_texto( 332, "-", sizeof("-"));	// Escreve "-"
			}
			if( interceptEletrodos[4] < 0 ){	// Se a posição da memória é negativa
				escrita_texto( 342, "-", sizeof("-"));	// Escreve "-"
			}
			escrita_texto(posicaoTexto[4], ConverteNumParaLcd(tamanhoDigito[4], 2, (unsigned int)(abs(slopeEletrodos[4] * 100))), ContaCaracteres()+1);	// Slope
			escrita_texto(posicaoTexto[9], ConverteNumParaLcd(tamanhoDigito[9], 2, (unsigned int)(abs(interceptEletrodos[4] * 100))), ContaCaracteres()+1);	// Intercept

			escrita_texto(420, "<=RESET", sizeof("<=RESET"));
			escrita_texto(450, "1=ENTRAR", sizeof("1=ENTRAR"));
			escrita_texto(459, "2=CAL", sizeof("2=CAL"));
			escrita_texto(465, "YES=Salvar", sizeof("YES=Salvar"));
			estadoCorrelacao = 1;
			break;

		case 1:

			if( flag_timer ){	// Se flag timer igual a 1
				flag_timer = 0;	// Flag timer recebe 0
				timeout++;	// Incrementa timeout de 1
				if( timeout >= 60000 || ( readTeclado ) == no )	// Se timeout é maior ou igual a 60000 (1 minuto) ou teclado igual a No
					return;
			}
			if( readTeclado == um ){	// Se teclado igual a 1

				estadoCorrelacao = 10;	// estadoCorrelacao recebe 10
				clearLine(15);	// Limpa a linha 15
				escrita_texto(450, "Entre com a senha:", sizeof("Entre com a senha:"));	// Escreve "Entre com a senha" na posição 450

			}
			else if( readTeclado == dois ){	// Senão se teclado igual a 2
				estadoCorrelacao = 20;	// estadoCorrelacao recebe 20, cálculo automático de correlação
			}else if( readTeclado == yes ){	// Senão se teclado igual a yes
				SalvaFlashConfiguracao(ADDR_CONFIGURACAO, 0xE2028,(int*) numeroInit); // Salva os dados em um vetor
				send_command(0x90);
				for( unsigned int i = 0; i < 65535; i++);
				send_command(Display_mode_text);
			}
			else if( readTeclado == left ){	// Senão se teclado igual a ←
				// Restaura os valores padrão (1.00 e 0.00, apenas escrita)
				// Escrtia do eletrodo K e dos valores salvos na flash
				escrita_texto(104, ConverteNumParaLcd(3, 2, 100), ContaCaracteres()+1);	// Slope
				escrita_texto(114, ConverteNumParaLcd(3, 2, 0), ContaCaracteres()+1);	// Intercept

				// Escrtia do eletrodo Na e dos valores salvos na flash
				escrita_texto(164, ConverteNumParaLcd(3, 2, 100), ContaCaracteres()+1);	// Slope
				escrita_texto(174, ConverteNumParaLcd(3, 2, 0), ContaCaracteres()+1);	// Intercept

				// Escrtia do eletrodo Cl e dos valores salvos na flash
				escrita_texto(224, ConverteNumParaLcd(3, 2, 100), ContaCaracteres()+1);	// Slope
				escrita_texto(234, ConverteNumParaLcd(3, 2, 0), ContaCaracteres()+1);	// Intercept

				// Escrtia do eletrodo Ca e dos valores salvos na flash
				escrita_texto(284, ConverteNumParaLcd(3, 2, 100), ContaCaracteres()+1);	// Slope
				escrita_texto(294, ConverteNumParaLcd(3, 2, 0), ContaCaracteres()+1);	// Intercept

				// Escrtia do eletrodo pH e dos valores salvos na flash
				escrita_texto(344, ConverteNumParaLcd(3, 2, 100), ContaCaracteres()+1);	// Slope
				escrita_texto(354, ConverteNumParaLcd(3, 2, 0), ContaCaracteres()+1);	// Intercept
				for( unsigned char i = 0; i < 10; i++ )
				{
					if( i < 5 )
					{
						numeroInit[i] = 1;
						slopeEletrodos[i] = 1;
					}
					else
					{
						numeroInit[i] = 0;
						interceptEletrodos[i-5] = 0;
					}
				}
				estadoCorrelacao = 0;
			}
			break;

		case 10:

			if( readTeclado == cinco ){	// Se tecla igual a 5
				contOk++;	// Incrementa contOk
				if( contOk == 2 ){	// Se contOk igual a 2, estadoCorrelacao recebe 11
					estadoCorrelacao = 11;

				}
			}
			else if( readTeclado != 16 ){	// Senão
				contOk = 0;	// contOk recebe 0
				estadoCorrelacao = 0;	// estadoCorrelacao recebe 0
				clear_display_text();
			}
			break;

		case 11:

			numero = EscreveTela( 13, 3, 6, 0 );
			for( unsigned char i = 0; i < 10; i++ )
			{
				numeroInit[i] = *(numero++);
				if( i < 5 )
				{
					slopeEletrodos[i] = numeroInit[i];
				}
				else
				{
					interceptEletrodos[i-5] = numeroInit[i];
				}
			}
			send_command(Display_mode_text);	// Desliga cursor e liga texto
			clearLine( 15 );
			escrita_texto(420, "<=RESET", sizeof("<=RESET"));
			escrita_texto(450, "1=ENTRAR", sizeof("1=ENTRAR"));
			escrita_texto(459, "2=CAL", sizeof("2=CAL"));
			escrita_texto(465, "YES=Salvar", sizeof("YES=Salvar"));
			estadoCorrelacao = 0;

			break;
		}
	}

}

float *EscreveTela( unsigned char posicaoX, unsigned char posicaoY, unsigned char contDigitos, unsigned char apenasNumeros  ){

	unsigned char tecla = 0, contaCaracter = 1, dadosTecla[contDigitos], posicaoInicialX = posicaoX, posicaoInicialY = posicaoY, posicaoPonto = 0;
	unsigned char addrMemoria = 0;
	unsigned short posicaoTexto = posicaoX + posicaoY * 30, posicaoTextoHifen;
	static float numero[10] = {1.0,1.0,1.0,1.0,1.0,0,0,0,0,0};

	// Atualização dos números anteriores
	for( int i = 0; i < 10; i++){
		if( *(volatile unsigned int *)(ADDR_CONFIGURACAO + i*4) != 0xFFFFFFFF ){
			numero[i] = *(volatile float *)(ADDR_CONFIGURACAO + i*4);
		}
	}

	Cursor( posicaoX, posicaoY, 1, 1 );// Define a posição do cursor

	for( int i = 0; i < contDigitos; i++){
		dadosTecla[i] = 0;
	}

	while(1){	// Enquanto 1

		tecla = verifyKeyBoard();	// Faz a leitura do teclado
		if( tecla != 16 && !apenasNumeros ){	// Se teclado diferente de 0
			posicaoTexto = posicaoX + posicaoY * 30;
			if( tecla == left ){			// Se teclado igual a left
				escrita_texto( posicaoTexto - 1, " ", sizeof(" "));		// Escreve ' '
				if( dadosTecla[posicaoPonto] == dot ){
					posicaoPonto = 0;
				}
				dadosTecla[contaCaracter] = 0;
				contaCaracter--;	// Decrementa contaCaracter
				if( contaCaracter == 0){	// Se chegar a 0
					contaCaracter = 1;	// contaCaracter recebe 1
				}
				if( posicaoX == posicaoInicialX || posicaoX == posicaoInicialX + 10 ){	// Se posicaoX igual a posicaoInicialX
					posicaoY -= 2;	// posicaoY subtrai 2
					if( posicaoY == 1 && posicaoX == 23 ){	// Quando a posiçãoY igual a 13
						posicaoX = 13;	// posiçãoX recebe 23
						posicaoY = 11;	// posiçãoY recebe 3
						posicaoInicialX = 13;
					}
					if( posicaoY < posicaoInicialY )	// Se posicaoY menor que posicaoInicialY
						posicaoY = posicaoInicialY;	// posicaoY recebe posicaoInicialY
					if( addrMemoria > 0 )	// Se o contador de endereço de memória é maior que 0
					{
						addrMemoria--;	// Decrementa o contador de endereço
					}
					else	// Senão
					{
						addrMemoria = 0;	// Contador de endereço recebe 0
					}
				}
				posicaoX--;	//Retorna a posição em 1
				if( posicaoX < posicaoInicialX + 5 ){
					if( posicaoX < posicaoInicialX )	// Impede que a posição da escrita seja menor que a inicial
						posicaoX = posicaoInicialX;
				}
				else if( posicaoX < posicaoInicialX + 10 ){
					posicaoX = posicaoInicialX + 10;
				}
				Cursor(posicaoX, posicaoY, 1, 1);

			}
			else if( tecla == no ){		// Se tecla igual a no, retorna
				return numero;	// Valor de saída
			}
			else if( tecla == hifen ){	// Se tecla igual a hifen

				posicaoTextoHifen = posicaoInicialX + posicaoY * 30;
				if( dadosTecla[0] != hifen ){	// Se o vetor na posicao 0 é diferente de hifen
					dadosTecla[0] = tecla;	// Vetor na posição 0 recebe hifen
					EscreveDigito( posicaoTextoHifen - 1, tecla );	// Desenha o hifen
				}
				else{	// Senão
					dadosTecla[0] = 0;	// O vetor na posição 0 recebe 0
					escrita_texto( posicaoTextoHifen - 1, " ", sizeof(" "));		// Escreve ' '
				}

			}
			else if( tecla == dot && posicaoPonto == 0 ){	// Se tecla for igual a ponto

				posicaoPonto = contaCaracter;// posicaoPonto recebe i)
				posicaoX++;	// Incrementa a posição em 1
				dadosTecla[contaCaracter] = tecla;	// data[contaCaracter] recebe teclado
				contaCaracter++;	// Incrementa contaCaracter
				Cursor(posicaoX, posicaoY, 1, 1);
				EscreveDigito( posicaoTexto, tecla );

			}

			// Se teclado diferente de 'yes' e diferente de 'no' e diferente de left e diferente de right
			if( tecla != yes && tecla != no && tecla != left && tecla != right && tecla != hifen && tecla != dot ){

				EscreveDigito( posicaoTexto, tecla );
				posicaoX++;	// Incrementa a posição em 1
				dadosTecla[contaCaracter] = tecla;	// data[contaCaracter] recebe teclado
				contaCaracter++;	// Incrementa contaCaracter
				Cursor(posicaoX, posicaoY, 1, 1);

			}

			if( contaCaracter == contDigitos || tecla == yes ){	// Se contaCaracter igual a contDigitos
				posicaoY += 2;  // Muda o número para as próximas posições (K, Na, Cl, Ca, pH)
				if( contaCaracter == 1 ){
					if( dadosTecla[0] == hifen ){
						escrita_texto( posicaoTexto - 1, " ", sizeof(" "));
					}
					if( posicaoY == 13 && posicaoX == 13 ){	// Quando a posiçãoY igual a 13
						posicaoX = 23;	// posiçãoX recebe 23
						posicaoY = 3;	// posiçãoY recebe 3
						posicaoInicialX = 23;
					}
					else if( posicaoY == 13 && posicaoX == 23 ){

						return numero;

					}
					addrMemoria++;
				}
				else{

					switch( posicaoPonto ){	// Posição do ponto no vetor de número
					case 1:	// Caso esteja na primeira posição
						// Número recebe dadosTecla[2] * 0.1 + dadosTecla[3] * 0.01 + dadosTecla[4] * 0.001 + dadosTecla[5] * 0.0001
						numero[addrMemoria] = dadosTecla[2] * 0.1 + dadosTecla[3] * 0.01 + dadosTecla[4] * 0.001 + dadosTecla[5] * 0.0001;
						break;
					case 2:	// Caso esteja na segunda posição
						// Número recebe dadosTecla[1] * 1 + dadosTecla[3] * 0.1 + dadosTecla[4] * 0.01 + dadosTecla[5] * 0.001;
						numero[addrMemoria] = dadosTecla[1] * 1 + dadosTecla[3] * 0.1 + dadosTecla[4] * 0.01 + dadosTecla[5] * 0.001;
						break;
					case 3:	// Caso esteja na terceira posição
						// Número recebe dadosTecla[1] * 10 + dadosTecla[2] * 1 + dadosTecla[4] * 0.1 + dadosTecla[5] * 0.01;
						numero[addrMemoria] = dadosTecla[1] * 10 + dadosTecla[2] * 1 + dadosTecla[4] * 0.1 + dadosTecla[5] * 0.01;
						break;
					case 4:	// Caso esteja na quarta posição
						// Número recebe dadosTecla[2] * 0.1 + dadosTecla[3] * 0.01 + dadosTecla[4] * 0.001 + dadosTecla[5] * 0.0001
						numero[addrMemoria] = dadosTecla[1] * 100 + dadosTecla[2] * 10 + dadosTecla[3] * 1 + dadosTecla[5] * 0.1;
						break;
					case 5:	// Caso esteja na quinta posição
						// Número recebe dadosTecla[2] * 0.1 + dadosTecla[3] * 0.01 + dadosTecla[4] * 0.001 + dadosTecla[5] * 0.0001
						numero[addrMemoria] = dadosTecla[1] * 1000 + dadosTecla[2] * 100 + dadosTecla[3] * 10 + dadosTecla[4] * 1;
						break;
					default:
						numero[addrMemoria] = 0;
						for( int i = 1; i < contaCaracter; i++ ){	// Para i começando de 1, i menor que contaCaracter, i incrementa de 1
							numero[addrMemoria] += dadosTecla[i]*pow(10,contaCaracter - 1 - i); // dadosTecla[i] vezes 10^( contaCaracter - 1 - i )
						}
						//numero[addrMemoria] = dadosTecla[1] * 10000 + dadosTecla[2] * 1000 + dadosTecla[3] * 100 + dadosTecla[4] * 10 + dadosTecla[5] * 1;
						break;
					}
					if( dadosTecla[0] == hifen && numero[addrMemoria] != 0 ){
						numero[addrMemoria] *= (-1);
					}
					else if( dadosTecla[0] == hifen && numero[addrMemoria] == 0 ){
						escrita_texto( posicaoTexto - contaCaracter, " ", sizeof(" "));
					}
					escrita_texto(posicaoTexto - (contaCaracter - 1), "      ", sizeof("      "));
					if( numero[addrMemoria] < -100 || numero[addrMemoria]  > 100 ){	// Se n° menor que -100 ou número maior que 100
						if( *(volatile unsigned int *)(ADDR_CONFIGURACAO + addrMemoria * 4) == 0xFFFFFFFF ){	// Se a memória não está salva
							numero[addrMemoria] = 1;
							escrita_texto(posicaoTexto - (contaCaracter - 2), ConverteNumParaLcd(3, 2, 100), ContaCaracteres()+1);	// Escreve o valor 1.00
						}
						else{	// Senão
							if( *(volatile float*)(ADDR_CONFIGURACAO + addrMemoria * 4) < 0 ){	// Se a posição da memória é negativa
								escrita_texto( posicaoTexto - contaCaracter, "-", sizeof("-"));	// Escreve "-"
							}
							else{// Senão
								escrita_texto( posicaoTexto - contaCaracter, " ", sizeof(" "));	// Escreve " "
							}
							// Verifica os valores na memória e escreve
							if( ( *(volatile float*)(ADDR_CONFIGURACAO + addrMemoria * 4) > -1 && *(volatile float*)(ADDR_CONFIGURACAO + addrMemoria * 4) < 1 )
									|| ( *(volatile float*)(ADDR_CONFIGURACAO + addrMemoria * 4) > -10 && *(volatile float*)(ADDR_CONFIGURACAO + addrMemoria * 4) < 10 ) ){
								escrita_texto(posicaoTexto - (contaCaracter - 2), ConverteNumParaLcd(3, 2,abs(*(volatile float*)(ADDR_CONFIGURACAO + addrMemoria * 4) * 100)), ContaCaracteres()+1);
							}
							else{
								escrita_texto(posicaoTexto - (contaCaracter - 1), ConverteNumParaLcd(4, 2,abs(*(volatile float*)(ADDR_CONFIGURACAO + addrMemoria * 4) * 100)), ContaCaracteres()+1);
							}
						}
					}
					else{	// Senão, escreve o número e armazena na memória
						// Verifica se está entre -1 e 1 ou -10 e 10
						if( ( numero[addrMemoria] > -1 && numero[addrMemoria] < 1 ) || ( numero[addrMemoria] > -10 && numero[addrMemoria] < 10 ) ){
							escrita_texto(posicaoTexto - (contaCaracter - 2), ConverteNumParaLcd(3, 2,(unsigned int)( abs(numero[addrMemoria] * 100))), ContaCaracteres()+1);
						}
						else{
							if( posicaoPonto != 0 ){
								escrita_texto(posicaoTexto - (contaCaracter - 2), ConverteNumParaLcd(4, 2,(unsigned int)( abs(numero[addrMemoria] * 100))), ContaCaracteres()+1);
							}
							else{
								escrita_texto(posicaoTexto - (contaCaracter - 1), ConverteNumParaLcd(4, 2,(unsigned int)( abs(numero[addrMemoria] * 100))), ContaCaracteres()+1);
							}
						}
					}
					posicaoX = posicaoX - ( contaCaracter - 1 );
					for( unsigned char i  = 0; i < 6; i++ ){
						dadosTecla[i] = 0;
					}
					contaCaracter = 1;	// Reinicia a contagem de caracteres
					posicaoPonto = 0;
					addrMemoria++;	// Incrementa contador de memória
					if( posicaoY == 13 && posicaoX == 13 ){	// Quando a posiçãoY igual a 13
						posicaoX = 23;	// posiçãoX recebe 23
						posicaoY = 3;	// posiçãoY recebe 3
						posicaoInicialX = 23;
					}
					else if(  posicaoY == 13 && posicaoX == 23 ){
						return numero;	// Retorna o ponteiro do número
					}
				}
				Cursor(posicaoX, posicaoY, 1, 1);
			}
		}
	}
}

void Cursor( unsigned char posicaoX, unsigned char posicaoY, unsigned char piscar, unsigned char tamanhoCursor ){

	send_data( posicaoX ); 	// Dado de posição 8 bits MSB
	send_data( posicaoY );	// Dado de posição 8 bits LSB
	send_command( Set_cursor_pointer );	// Envia o comando de cursor
	if( piscar )	// Se piscar igual a 1
		send_command( 0x97 );	// Envia o comando 0x97 - Manual SAP1024B - Comando do cursor
	else	// Senão
		send_command( 0x96 );	// Envia o comando 0x96 - Manual SAP1024B - Comando do cursor
	switch( tamanhoCursor ){	// Escolha o tamanho do Cursor
	case 1:// Caso 1
		send_command( 0xA0 );	// Envia o comando 0xA0 - Manual SAP1024B - Comando do cursor
		break;
	case 2:// Caso 2
		send_command( 0xA1 );	// Envia o comando 0xA0 - Manual SAP1024B - Comando do cursor
		break;
	case 3:// Caso 3
		send_command( 0xA2 );	// Envia o comando 0xA0 - Manual SAP1024B - Comando do cursor
		break;
	case 4:// Caso 4
		send_command( 0xA3 );	// Envia o comando 0xA0 - Manual SAP1024B - Comando do cursor
		break;
	case 5:// Caso 5
		send_command( 0xA4 );	// Envia o comando 0xA0 - Manual SAP1024B - Comando do cursor
		break;
	case 6:// Caso 6
		send_command( 0xA5 );	// Envia o comando 0xA0 - Manual SAP1024B - Comando do cursor
		break;
	case 7:// Caso 7
		send_command( 0xA6 );	// Envia o comando 0xA0 - Manual SAP1024B - Comando do cursor
		break;
	case 8:// Caso 8
		send_command( 0xA7 );	// Envia o comando 0xA0 - Manual SAP1024B - Comando do cursor
		break;
	}
}

void EscreveDigito( unsigned int posicao, unsigned char tecla ){

	switch( tecla ){	// Escolha teclado
	case zero:	// Caso zero:
		escrita_texto( posicao, "0", sizeof("0"));	// Escreve '0'
		break;

	case um:	// Caso um:
		escrita_texto( posicao, "1", sizeof("1"));	// Escreve '1'
		break;

	case dois:	// Caso dois:
		escrita_texto( posicao, "2", sizeof("2"));	// Escreve '2'
		break;

	case tres:	// Caso tres:
		escrita_texto( posicao, "3", sizeof("3"));		// Escreve '3'
		break;

	case quatro:	// Caso quatro:
		escrita_texto( posicao, "4", sizeof("4"));		// Escreve '4'
		break;

	case cinco:	// Caso cinco:
		escrita_texto( posicao, "5", sizeof("5"));		// Escreve '5'
		break;

	case seis:	// Caso seis:
		escrita_texto( posicao, "6", sizeof("6"));		// Escreve '6'
		break;

	case sete:	// Caso sete:
		escrita_texto( posicao, "7", sizeof("7"));		// Escreve '7'
		break;

	case oito:	// Caso oito:
		escrita_texto( posicao, "8", sizeof("8"));		// Escreve '8'
		break;

	case nove:	// Caso nove:
		escrita_texto( posicao, "9", sizeof("9"));		// Escreve '9'
		break;

	case hifen:	// Caso hifen:
		escrita_texto( posicao, "-", sizeof("-"));		// Escreve '-'
		break;

	case dot:			// Caso dot:
		escrita_texto( posicao, ".", sizeof("."));		// Escreve '.'
		break;

	}
}

void SalvaFlashConfiguracao( unsigned int enderecoInicial, unsigned int enderecoFinal, int *dados ){

	unsigned int deltaMemoria = enderecoFinal - enderecoInicial, vetorMemoria[256];	// Diferença entre endereço final e inicial
	uint32_t i = ADDR_CONFIGURACAO;
	// Para i começando de ADDR_CONFIGURACAO(0xE2000), i menor que ADDR_CONFIGURACAO(0xE2000) + 0x1000; i incrementa DADO_MEMORIA (4)
	for( i = i ; i < ADDR_CONFIGURACAO + 0x1000; i = i + DADO_MEMORIA ){

		if( *(volatile unsigned int *)(i) != 0xFFFFFFFF )	// Se memória estiver gravada
			vetorMemoria[(i - ADDR_CONFIGURACAO)/4] = *(volatile unsigned int *)(i);	// Vetor memória recebe o que está salvo na posição de memória

	}
	i = enderecoInicial - ADDR_CONFIGURACAO;
	// Para i igual a enderecoFinal - ADDR_CONFIGURACAO, i menor que deltaMemoria (diferença de endereços), i incrementa DADO_MEMORIA (4)
	for( i = i ; i < deltaMemoria; i = i + DADO_MEMORIA ){

		vetorMemoria[i/4] = *(dados++);

	}

	FLASH_Erase(&s_flashDriver, 0xE2000, 0x1000, kFLASH_ApiEraseKey);	// Apaga a memória

	FLASH_Program(&s_flashDriver, ADDR_CONFIGURACAO, vetorMemoria, 1024);	// Escreve na memória

}

unsigned char ContaDigitos( unsigned int num )
{
	if( num >= 10000 )	// Se num maior ou igual a 10000
	{
		return 5;	// retorna 5
	}
	else if( num >= 1000 )	// Senão se num maior ou igual a 1000
	{
		return 4;	// retorna 4
	}
	else if( num >= 100 )	// Senão se num maior ou igual a 100
	{
		return 3;	// retorna 3
	}
	else if( num >= 10 )	// Senão se num maior ou igual a 10
	{
		return 2;	// retorna 2
	}
	else	// Senão
	{
		return 1;	// retorna 1
	}
}

unsigned long long EscreveCodigoDeBarras( void )
{
	unsigned char tecla = verifyKeyBoard(), contaCaracter = 0, posicaoX = 5, dadosTecla[12], posicao = 35;
	unsigned long long codigoDeBarras = 0;
	unsigned int timeout = 0;
	Cursor(posicaoX, 1, 1, 1);
	while( tecla != no && timeout < 60000 ) // Enquanto tecla diferente de 16 e timeout menor que 60000 (1 minuto)
	{
		if( flag_timer )	// Se flag timer igual a 1
		{
			flag_timer = 0;	// Flag timer recebe 0
			timeout++;	// Incrementa timeout de 1
		}
		tecla = verifyKeyBoard();	//	tecla recebe verifyKeyBoard
		if( tecla != 16 )
		{
			timeout = 0;	//	Timeout recebe 0
			if( tecla != dot && tecla != hifen && tecla != right && tecla != left && tecla != yes )	//	Se tecla diferente de dot, hifen e right
			{
				escrita_texto( posicao + contaCaracter, "             ", sizeof("             "));
				EscreveDigito( posicao + contaCaracter, tecla );	//	Escreve tecla
				dadosTecla[11 - contaCaracter] = tecla;	// 	dadosTecla na posicao 12 - contaCaracter recebe tecla
				contaCaracter++;	//	contaCaracter incrementa 1
				if( contaCaracter == 12 )	// 	Se contaCaracter igual a 12
				{
					for( unsigned char i = 0; i	< contaCaracter; i++ )// loop para codigoDeBarras soma dadosTecla[12 - contaCaracter] * 10 ^ (contaCaracter - 1 - i)
					{
						codigoDeBarras +=  dadosTecla[12 + i - contaCaracter] * pow(10,i);
					}
					send_command(Display_mode_text);	// Desliga cursor e liga texto
					escrita_texto( 35, ConverteNumParaLcd( 2, 0, ( codigoDeBarras / 10000000000 )), ContaCaracteres() + 1 );	// Escreve o dia salvo com 2 dígitos
					escrita_texto( 37, ConverteNumParaLcd( 5, 0, ( codigoDeBarras % 10000000000 / 100000 ) ), ContaCaracteres() + 1 );	// Escreve o dia salvo com 2 dígitos
					escrita_texto( 42, ConverteNumParaLcd( 5, 0, codigoDeBarras % 100000 ), ContaCaracteres() + 1 );	// Escreve o dia salvo com 2 dígitos
					return codigoDeBarras;
				}

			}
			else if( tecla == left )	//	Senão se tecla igual a left
			{
				escrita_texto(posicao + contaCaracter, " ", sizeof(" "));
				timeout = 0;	//	Timeout recebe 0
				if( contaCaracter > 0 )	// Se contaCaracter maior que 0
				{
					contaCaracter--;	// contaCaracter decrementa 1
				}
				else	// Senão
				{
					contaCaracter = 0;	// contaCaracter recebe 0
				}
			}
			else if( tecla == yes || contaCaracter == 12 )	//	Senão se tecla igual a yes
			{
				for( unsigned char i = 0; i	< contaCaracter; i++ )// loop para codigoDeBarras soma dadosTecla[12 - contaCaracter] * 10 ^ (contaCaracter - 1 - i)
				{
					codigoDeBarras +=  dadosTecla[12 + i - contaCaracter] * pow(10,i);
				}
				send_command(Display_mode_text);	// Desliga cursor e liga texto
				escrita_texto( 35, ConverteNumParaLcd( 2, 0, ( codigoDeBarras / 10000000000 )), ContaCaracteres() + 1 );	// Escreve o dia salvo com 2 dígitos
				escrita_texto( 37, ConverteNumParaLcd( 5, 0, ( codigoDeBarras % 10000000000 / 100000 ) ), ContaCaracteres() + 1 );	// Escreve o dia salvo com 2 dígitos
				escrita_texto( 42, ConverteNumParaLcd( 5, 0, codigoDeBarras % 100000 ), ContaCaracteres() + 1 );	// Escreve o dia salvo com 2 dígitos
				return codigoDeBarras;
			}

			Cursor( posicaoX + contaCaracter, 1, 1, 1 );		// 	Move o cursor para a direita (posicaoX soma contaCaracter)
		}
	}
	send_command(Display_mode_text);	// Desliga cursor e liga texto
	return 0;
}

void DadosDeCalibracao(void){

	clear_display_text();
	unsigned char contaCalibracao = 0;

	if( *(volatile unsigned int *)(ADDR_CALIBRACAO) == 0xFFFFFFFF ){	// Se a memória foi escrita
		escrita_texto(155, "SEM DADOS GRAVADOS", sizeof("SEM DADOS GRAVADOS"));
		vTaskDelay(500);
		return;
	}
	for( unsigned int i = ADDR_CALIBRACAO; i <= ADDR_CALIBRACAO + 0x768; i = i + DADOS_CALIBRACAO ){	// Faz a verificação de memória apagada
		if( *(volatile unsigned int *)(i) == 0xFFFFFFFF ){ // Chegou ao final
			break;
		}
	contaCalibracao++;
	}

}














